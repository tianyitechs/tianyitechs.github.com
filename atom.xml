<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Linux基础</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-03-13T08:39:46.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用Python搭建聊天机器人</title>
    <link href="http://yoursite.com/2017/03/13/robot/"/>
    <id>http://yoursite.com/2017/03/13/robot/</id>
    <published>2017-03-13T08:39:46.000Z</published>
    <updated>2017-03-13T08:39:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>Python官网下载<a href="https://www.python.org/downloads/windows/" target="_blank" rel="external">安装包</a>,选择<strong>Download Windows x86-64 executable installer</strong>,一路next,以安装到D盘根目录为例.以管理权限打开命令提示符,切换到Python安装目录的Scripts目录下,安装wxpy库，如图：<br><img src="./wxpy.png" alt="wxpy"><br>接下来安装translate库， 在当前命令窗口中执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip3.exe install tranlate</div></pre></td></tr></table></figure></p>
<p>##源码部分<br>以下是源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"># -*- coding: utf-8 -*-</div><div class="line"></div><div class="line">from wxpy import *</div><div class="line">import requests</div><div class="line">import json</div><div class="line">import time</div><div class="line">from translate import Translator</div><div class="line"></div><div class="line">def talk_aiml(msg):</div><div class="line">   </div><div class="line">    translator=Translator(to_lang=&apos;en&apos;,from_lang=&apos;zh&apos;)</div><div class="line">    backtranslator=Translator(to_lang=&apos;zh&apos;,from_lang=&apos;en&apos;)</div><div class="line">    msg_en=translator.translate(msg)</div><div class="line">    str=&apos;http://lwons.com/aiml?req=&apos;+msg_en</div><div class="line">    </div><div class="line">    r = requests.get(str)</div><div class="line">    return (backtranslator.translate(r.text))</div><div class="line"></div><div class="line"></div><div class="line">def talk(msg):</div><div class="line">    str=&apos;http://api.qingyunke.com/api.php?key=free&amp;appid=0&amp;msg=&apos;+msg</div><div class="line">    r = requests.get(str)</div><div class="line">    print(r)</div><div class="line">    data=r.json()</div><div class="line">    print(data)</div><div class="line">    return data[&apos;content&apos;]</div><div class="line"></div><div class="line">robot = Robot()</div><div class="line"></div><div class="line">@robot.register()</div><div class="line">def reply_my_friend(msg):</div><div class="line">  print(msg)</div><div class="line">  return talk_aiml(msg.text)</div><div class="line"></div><div class="line">robot.start()</div></pre></td></tr></table></figure>
<p>##执行<br>1.copy以上代码,保存到robot.py,以D盘根目录为例<br>打开程序列表中Python中IDLE<br><img src="./ide.png" alt="IDLE"></p>
<p>选择File-&gt;Open,找到之前保存的robot.py,按F5执行，出现一个二维码，微信扫码可以启动脚本,然后可以enjoy这段脚本了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;p&gt;Python官网下载&lt;a href=&quot;https://www.python.org/downloads/windows/&quot; target=&quot;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Bash" scheme="http://yoursite.com/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基础概念</title>
    <link href="http://yoursite.com/2017/02/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2017/02/15/机器学习基础概念/</id>
    <published>2017-02-15T10:19:19.000Z</published>
    <updated>2017-03-13T08:04:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><strong>机器学习</strong>是如今人工智能领域中进展最大的方面，更多的初学者开始进入了这个领域。</p>
<p>机器学习是人工智能的一个分支，它通过构建算法让计算机学习，并且在数据集上使用这些算法来完成任务。那意味着我们可以对计算机进行编码，让它们自己去学习东西！</p>
<p>学习的能力是智能最重要的一个方面。将这种能力运用到机器上，应该是向让计算机更智能迈出了一大步。事实上，机器学习是如今人工智能领域中进展最大的方面。<br>常见的分类：</p>
<h2 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h2><p>图像处理的问题基本上都需要分析图像获取数据或是做一些转换。下面是一些例子：</p>
<h3 id="图像标记"><a href="#图像标记" class="headerlink" title="图像标记"></a>图像标记</h3><p>比如在微博中，算法可以自动检测照片中出现的你的或者你朋友的脸。基本上是机器学习算法从你手动标记的照片中学习。</p>
<h3 id="光学字符识别（OCR）"><a href="#光学字符识别（OCR）" class="headerlink" title="光学字符识别（OCR）"></a>光学字符识别（OCR）</h3><p>算法学会将手稿或者扫描文本转换成数字化版本。该算法需要学会将手写字符图像转换成相应的数字化字母。</p>
<h3 id="自动驾驶"><a href="#自动驾驶" class="headerlink" title="自动驾驶"></a>自动驾驶</h3><p>让汽车通过图像处理来自动驾驶的机制之一。机器学习算法通过摄像机拍摄的每一帧图像来学习哪里是道路的边缘，哪里需要变换车道,是否有停车标志或者是否有车靠近。</p>
<h2 id="文本分析"><a href="#文本分析" class="headerlink" title="文本分析"></a>文本分析</h2><p>文本分析是我们从文本文件，比如微博，邮件，聊天记录，文档等中提取或分类信息。下面是一些流行的例子：</p>
<h3 id="垃圾邮件过滤"><a href="#垃圾邮件过滤" class="headerlink" title="垃圾邮件过滤"></a>垃圾邮件过滤</h3><p>是最为人知也是最常用的文本分类应用（给文本分类）之一。垃圾邮件过滤器学习如何基于内容和主题将邮件归类为垃圾邮件。</p>
<h3 id="情感分析"><a href="#情感分析" class="headerlink" title="情感分析"></a>情感分析</h3><p>文本分类的另一个应用，该算法必须学会基于作者表达的情绪，来将一个观点分类成积极、中立或者消极。</p>
<h3 id="信息提取"><a href="#信息提取" class="headerlink" title="信息提取"></a>信息提取</h3><p>从文本中，学会提取特定的信息或数据块，比如，提取地址，实体，关键词等。</p>
<h2 id="数据挖掘"><a href="#数据挖掘" class="headerlink" title="数据挖掘"></a>数据挖掘</h2><p>数据挖掘是用来从数据中发现某些模式或者做出预测。这个定义有点普通，不过你可以理解成从海量数据库表中挖掘有用的信息。每一行都可以是我们的训练实例，每一列都可以作为一个特征。我们可能会感兴趣用表中剩下的列来预测一条新的列，或者发现某种模式来对行进行分组。比如：</p>
<p>###异常检测<br>检测异常值，例如信用卡欺诈检测，你可以从一个用户平常的购物模式来检测哪些购物方式是异常行为。</p>
<p>###关联规则<br>比如，在超市或者电子商务网站，你可以通过观察哪些产品会一起被购买来发现客户的购买习惯。这些信息可以用于营销目的。</p>
<p>###分组<br>比如，在SaaS平台，可以通过用户行为和资料来对用户进行分组。<br>预测：从剩余变量中预测出另一个变量（数据库中的一列）。比如，你可以通过对现有客户资料和信用评分这些信息来学习并预测新客户的信用评分。</p>
<h2 id="机器学习定义"><a href="#机器学习定义" class="headerlink" title="机器学习定义"></a>机器学习定义</h2><p>对于某类任务T和性能度量P，如果一个计算机程序在T上以P衡量的性能随着经验E而自我完善，那么我们称这个计算机程序在从经验E学习。</p>
<p>比如，人工游戏玩家要学会下国际象棋（任务T），可以通过查看以前国际象棋比赛或与导师对弈（经验E）来学习。它的性能P可以用它与人类玩家对弈获胜的比例来度量。</p>
<p>更多例子：</p>
<h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><p>向系统中输入一张图片，系统需要判别图片中是否有巴拉克·奥巴马的脸（一般来说是类似于Facebook的图像自动标记）。</p>
<h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p>向系统中输入一条微博，系统判别这条微博是否带有积极或消极情感。</p>
<h3 id="案例3"><a href="#案例3" class="headerlink" title="案例3"></a>案例3</h3><p>向系统中输入某人的一些信息，系统计算出此人偿还信用卡贷款的概率。</p>
<p>在案例1中，系统任务是检测巴拉克·奥巴马的脸何时在图像中出现。可以将他出现在哪些照片或不出现在哪些照片中的信息作为经验。系统的性能可以用系统正确识别出奥巴马脸的次数比例来度量。</p>
<p>在案例2中，系统任务是对一条微博进行情感分析。系统的经验可以是一组微博和与它们相对应的情绪。系统的性能可以由系统对新推文情感分析正确的比例来度量。</p>
<p>在案例3中，系统任务是进行信用评分。系统可以将一系列用户资料和相对应的信用评分作为经验。可以用平方误差（预测和预期得分之间的差异）作为性能度量。</p>
<p>为了让算法学习将输入转换成期望的输出，你必须提供训练实例或者训练样例，也就是经验E。一组训练集是一系列实例的集合，它们将作为样例，机器学习算法从这些样例中学习并且完成预期任务。很好理解。</p>
<p>每一个训练实例通常表示为一组固定的属性或特征。特征是用来表示每一个实例的方式。例如，在案例1中，一张图片可以由每个像素的灰度级别来表示。在案例2中，微博可以用微博中出现的字词来表示。在案例3中，信用记录可以用此人的年龄、薪水、职业等来表示。</p>
<p>计算和选择合理的特征来表示一个实例是使用机器学习的过程中最重要的任务之一。</p>
<h2 id="机器学习算法的种类"><a href="#机器学习算法的种类" class="headerlink" title="机器学习算法的种类"></a>机器学习算法的种类</h2><p>在本节中我们将讨论两大类机器学习算法：监督式学习和非监督式学习算法。这两类算法的主要区别在于我们提供给算法的训练样例，算法使用样例的方式以及它们解决问题的类别。</p>
<h3 id="监督式学习"><a href="#监督式学习" class="headerlink" title="监督式学习"></a>监督式学习</h3><p>在监督式学习中，机器学习算法可以看作是将特定输入转换成期望输出的过程。</p>
<p>机器学习需要学会如何将所有可能输入转换成正确/期望输出，所以每个训练样例都有特定的输入和期望输出。</p>
<p>在人工国际象棋手的案例中，输入可以是特定的棋盘状态，输出则可能是在这一状态下最好的下棋方式。</p>
<p>根据输出的不同，我们又可以把监督式学习分为两小类：</p>
<p><strong>分类</strong>:当输出值属于离散和有限集合，那么这就是一个分类问题。案例2可以看作是一个分类问题，输出是一个有限集合：积极，消极或者中立，我们的训练样例是这样的：</p>
<pre><code>| Text       | Sentiment |
| -----------| ---------:|
| 好难过      | Negative  |  
| 好开心      | Positive  |    
| .....      | ....      |
</code></pre><p><strong>回归</strong>:当输出是连续的数值，比如，概率，那么这就是一个回归问题。案例3就是一个回归问题，因为结果是介于0到1的数字，它代表一个人偿还债务的概率。在这个案例下，我们的训练样例是这样的：</p>
<pre><code>| 职业     | 收入   | 年龄 | 评分 |
| --------| -------|-----|-----|
| 程序猿   | &lt;10k   | 26  | 0.3 |
| 产品经理 | &gt;20k  | 30   | 0.5 |
|...      |...    |...  |.... |
</code></pre><p>监督式学习是机器学习算法中最受欢迎的一类。使用这种方法的缺陷是，对于每一个训练样例，我们都需要提供与之对应的正确输出，在大多情况下，这会耗费大量人力物力财力。机器学习算法最常见的瓶颈：收集正确标记的训练数据。</p>
<h3 id="非监督式学习"><a href="#非监督式学习" class="headerlink" title="非监督式学习"></a>非监督式学习</h3><p>第二类机器学习算法叫做非监督式学习。在这种情况下，训练数据只需要输入到算法中即可，不需要有与之对应的期望输出。典型的用例就是发现训练样例之间隐藏的结构或者关系。典型的案例就是聚类算法，我们学习找到相似实例或者一组实例（。比如我们有一条新闻，我们希望推荐一条相似的新闻。一些聚类算法比如K-means从输入数据中来学习。</p>
<h2 id="机器学习算法"><a href="#机器学习算法" class="headerlink" title="机器学习算法"></a>机器学习算法</h2><p>为了将输入转换成期望输出，我们可以使用不同的模型。机器学习算法并不是唯一的，你可能听说过支持向量机，朴素贝叶斯，决策树或者深度学习。那些是不同的机器学习算法，它们都可以解决同样的问题：学习将输入转换成正确的输出。</p>
<p>那些不同的机器学习算法使用不同的范式或技术来执行学习过程，并将它们所学知识表示出来。</p>
<p>学习每一个算法之前，我们要了解，最常见的原则是，机器学习算法试图达到一般化。也就是说，它们试图用最简单的理论来解释事物。所有机器学习算法，不管它所使用的范式如何，都将尝试创建最简单的假设（做出最少假设的那个）来说明大部分的训练实例。</p>
<p>有很多机器学习算法，不过我们来简要介绍下三种流行的算法：</p>
<h3 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h3><p>该模型试图构建一个超平面高维空间集，它试图通过计算与最近实例最大距离来区分不同类的实例。这个概念直观简单，但是该模型有时候也会非常复杂和强大。事实上，对于某些领域支持向量机是你目前可以使用的最好的机器算法之一。</p>
<h3 id="概率模型"><a href="#概率模型" class="headerlink" title="概率模型"></a>概率模型</h3><p>这类模型通常通过对问题进行概率分布建模来预测正确的响应。这类算法中最流行的可能要属朴素贝叶斯分类器了，它使用贝叶斯定理和特征之间独立性假设来构建分类器。这个模型的优势之一是即简单又强大，而且不仅会返回预测值还会返回预测值的确定度，这是非常有用的。</p>
<h3 id="深度学习："><a href="#深度学习：" class="headerlink" title="深度学习："></a>深度学习：</h3><p>是基于大名鼎鼎的人工神经网络模型的机器学习的新领域。神经网络有着联结的操作方式，它们试图模仿（以非常简单的方式）大脑的工作方式。基本上，它们由一组相互关联的神经元（处理的基本单位）组成，这些神经元被组织成许多层。简单来说，深度学习使用更深的层构建了新的结构，通过高层次抽象改进了算法，不仅改进了学习方式，而且构建了自动表示最重要特征的结构。</p>
<h2 id="机器学习中的重要方面"><a href="#机器学习中的重要方面" class="headerlink" title="机器学习中的重要方面"></a>机器学习中的重要方面</h2><p>机器学习听起来是个美妙的概念，它确实如此，但是机器学习中有一些过程并不是那么自动完成的。事实上，在设计解决方案时，很多时候需要人工操作。然而，这是得到优良结果至关重要的一环。其中一些方面有：</p>
<p>我该使用哪类机器学习算法？</p>
<p>监督式还是非监督式？</p>
<p>有标记的数据吗？也就是输入和对应的输出。如果有，那么你可以使用监督式学习算法。如果没有，那么使用非监督式算法可以解决问题。</p>
<p>分类，回归还是聚类？</p>
<p>这主要取决于想要解决什么样的问题。如果你想标记数据（用离散的选项来标记），分类可能是正确的选择。相反，如果你想选择一个数字，比如说分数，回归则是你最佳的选择。或者想在电子商务网站上针对用户目前浏览信息来推荐相似产品，那么聚类则是你最好的选择。</p>
<p>深度学习，SVM，朴素贝叶斯，决策树···哪个最好？</p>
<p>我的答案是：没有最好的。显然，深度学习和支持向量机已经证明，在不同应用中它们是最强大和最灵活的算法。但考虑到根据不同特定应用，一些机器学习算法可能比其他算法更好。分析它们各自的优势并且使用它们！</p>
<h3 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h3><p>特征工程是我们提取、选择用来表示训练样例和实例的最重要的特征供机器学习算法处理的过程。这个过程是机器学习中最重要的方面。</p>
<p><strong>注意</strong>：如果不能向算法提供有质量保证的特征，即使使用了此情形下最好的机器学习算法，也得不到期望的结果。</p>
<h3 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h3><p>为了向机器学习算法输入数据，你通常需要将原始数据转换成算法能够“理解”的东西。这个过程被称作特征提取。通常我们将原始数据转换成特征向量。</p>
<p>在案例1中，我们如何向机器学习算法输入一张图像呢？</p>
<p>一个直接的方式就是将图像转换成向量，每一个成分是图像中每一个像素的灰度值。所以每一个成分或者特征，都可以用0到255的值表示，0表示黑色，255表示白色，1到254是不同程度的灰色。</p>
<p>这种方式可能可行，但是如果我们提供更细致的特征可能会工作得更好：</p>
<p>图像包含人脸吗？<br>肤色是什么？<br>眼睛是什么颜色的？<br>脸上有毛发吗？<br>…<br>这些是更细致特征，它们向算法提供了更多的知识而不只是每个像素的灰度值（它们的计算可以用其他机器学习算法来完成）。通过提供更高层次特征我们就在“帮”机器学习算法得到更好的学习信息来判断我的或者其他某个人的脸是否出现在一张图像中。</p>
<p>如果我们实施更好的特征提取：</p>
<p>我们算法能够学习并得到预期结果的可能性会更高。<br>我们可能不需要那么多训练样例。<br>这样一来，我们可以显著减少训练模型所需的时间。</p>
<h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><p>有些时候（并不是大多情况下），我们选择向算法输入的特征可能并没多大用处。比如，当对一条微博进行情感标记的时候，我们可能将微博的长度，微博发表的时间等作为特征，这些特征可能有用也可能没有用。</p>
<p>避免使用海量特征集。有些人可能尝试添加所有可能的特征到模型中让算法来学习。但这不是个好主意，当我们添加更多的特征来代表实例时，空间的维度就增加了，使得矩阵更加稀疏。直观地，因为我们得到更多的特征，我们必须有非常多的实例在表示每个特征的组合。这就是所谓的维度灾难，随着模型复杂度的增长，训练样例的数目需要以指数形式随着增长。</p>
<h3 id="训练样例"><a href="#训练样例" class="headerlink" title="训练样例"></a>训练样例</h3><p>必须向机器学习算法输入训练样例。取决于想要解决的问题，有可能使用到几百，几千，几百万甚至上亿的训练样例。而且，保持样例的质量也至关重要，如果你向算法中输入了错误的样例，得到良好结果的可能性会降低。</p>
<p>收集大量的优质数据来训练机器学习算法通常是一项耗费人力物力的工作。一些众包平台的工具尝试解决这样的问题，可以在这里找到一些工具来完成任务。或者通过使用自己的机器学习模型生成的辅助程序也可以将标记操作变得更高效。</p>
<p>训练样本的一般规则是：你收集了越是优质的训练数据，你可能就可能得到更好的训练结果。</p>
<h3 id="测试样本和性能指标"><a href="#测试样本和性能指标" class="headerlink" title="测试样本和性能指标"></a>测试样本和性能指标</h3><p>训练完一个机器学习模型之后，我们需要测试它的性能。这是非常重要的，否则你不知道你的模型是否学会了东西！</p>
<p>这个概念非常简单，我们使用一个测试集，一个不包含在训练集中的实例集合。基本上，我们将输入每个测试样本到模型中，然后观察它是否会得出预期结果。在监督式学习分类的情形中，我们只需要输入每条测试数据，然后检查模型输出是否与预期一样。如果我们的模型正确得出了95%的测试样本的结果，我们说这个模型的准确率是95%。</p>
<p>需要牢记的是，训练和测试数据集不能重合，这是测试模型泛化能力和预测能力的唯一途径。可能在你的训练数据上能够得到较高的准确率，但如果在单独的测试集上则得到较差的准确率。这就是过拟合，也就是算法对训练样本过度拟合导致糟糕的预测能力。通常避免过拟合的方法是使用较少特征的，更简单的模型，简化模型，并使用更大更具代表性的训练集。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>在实际应用中，如果你要实施解决方案，你必须建立一个强大和高性能的解决方案。在机器学习应用中，这会是一个复杂的任务。首先，你需要选择机器学习框架，这不是项容易的工作，因为并不是所有的编程语言都有相关的强大工具。Python和Scikit-learn是构建强大机器学习框架可以使用的编程语言的良好例子。</p>
<p>选择好框架之后，就要考虑性能问题了。取决于数据量，复杂度和设计的算法，运行训练算法可能会耗费大量的计算时间和内存。你可能需要运行多个训练算法直到得到优良的结果。而且，通常可能会用新实例来重新训练模型来提高准确率。</p>
<p>为了在使用时训练大量模型并快速的到结果，通常使用较大内存和多核处理器的机器来并行训练模型。</p>
<p>这些大多是实际问题，如果想部署机器学习解决方案到实际应用中，考虑这些问题是非常重要的。</p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>机器学习是很强大的，但训练它也是艰难的，这篇文章中所说的训练模型时可能出现的困难只是冰山一角。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;机器学习&lt;/strong&gt;是如今人工智能领域中进展最大的方面，更多的初学者开始进入了这个领域。&lt;/p&gt;
&lt;p&gt;机器学习是人工
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Bash" scheme="http://yoursite.com/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>ch9-流程控制</title>
    <link href="http://yoursite.com/2017/02/10/ch9-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2017/02/10/ch9-流程控制/</id>
    <published>2017-02-10T07:35:07.000Z</published>
    <updated>2017-02-10T09:12:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="1-for循环"><a href="#1-for循环" class="headerlink" title="1.for循环"></a>1.for循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">for planet in Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto</div><div class="line">do</div><div class="line">echo $planet  </div><div class="line">done</div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line">for planet in &quot;Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto&quot;</div><div class="line">do</div><div class="line">echo $planet</div><div class="line">done</div><div class="line"></div><div class="line">exit 0</div></pre></td></tr></table></figure>
<p>2.while循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">var0=0</div><div class="line">LIMIT=10</div><div class="line"></div><div class="line">while [ &quot;$var0&quot; -lt &quot;$LIMIT&quot; ]</div><div class="line">do</div><div class="line">  echo -n &quot;$var0 &quot;        # -n 将会阻止产生新行.</div><div class="line">  #                     ^           空格, 数字之间的分隔.</div><div class="line"></div><div class="line">  var0=`expr $var0 + 1`   # var0=$(($var0+1))  也可以.</div><div class="line">  # var0=$((var0 + 1)) 也可以.</div><div class="line">  # let &quot;var0 += 1&quot;    也可以.</div><div class="line">done                      # 使用其他的方法也行.</div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line">exit 0</div></pre></td></tr></table></figure>
<p>3.until循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">END_CONDITION=end</div><div class="line"></div><div class="line">until [ &quot;$var1&quot; = &quot;$END_CONDITION&quot; ]</div><div class="line"># 在循环的顶部进行条件判断.</div><div class="line">do</div><div class="line">  echo &quot;Input variable #1 &quot;</div><div class="line">  echo &quot;($END_CONDITION to exit)&quot;</div><div class="line">  read var1</div><div class="line">  echo &quot;variable #1 = $var1&quot;</div><div class="line">  echo</div><div class="line">done  </div><div class="line"></div><div class="line">exit 0</div></pre></td></tr></table></figure>
<h2 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h2><h3 id="1-嵌套循环"><a href="#1-嵌套循环" class="headerlink" title="1.嵌套循环"></a>1.嵌套循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"># nested-loop.sh: 嵌套的&quot;for&quot;循环.</div><div class="line"></div><div class="line">outer=1             # 设置外部循环计数.</div><div class="line"></div><div class="line"># 开始外部循环.</div><div class="line">for a in 1 2 3 4 5</div><div class="line">do</div><div class="line">  echo &quot;Pass $outer in outer loop.&quot;</div><div class="line">  echo &quot;---------------------&quot;</div><div class="line">  inner=1           # 重置内部循环计数.</div><div class="line"></div><div class="line">  # ===============================================</div><div class="line">  # 开始内部循环.</div><div class="line">  for b in 1 2 3 4 5</div><div class="line">  do</div><div class="line">    echo &quot;Pass $inner in inner loop.&quot;</div><div class="line">    let &quot;inner+=1&quot;  # 增加内部循环计数.</div><div class="line">  done</div><div class="line"># 内部循环结束.</div><div class="line"># ===============================================</div><div class="line"></div><div class="line">  let &quot;outer+=1&quot;    # 增加外部循环的计数.</div><div class="line">  echo              # 每次外部循环之间的间隔.</div><div class="line">done</div><div class="line"># 外部循环结束.</div><div class="line"></div><div class="line">exit 0</div></pre></td></tr></table></figure>
<p>注意： 为了能够更友好的让自己或者别人阅读和维护你的代码，应在代码中使用合理的缩进</p>
<h2 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h2><h3 id="1-break"><a href="#1-break" class="headerlink" title="1.break"></a>1.break</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">LIMIT=19  # 上限</div><div class="line"></div><div class="line">echo</div><div class="line">echo &quot;Printing Numbers 1 through 20 (but not 3 and 11).&quot;</div><div class="line"></div><div class="line">a=0</div><div class="line"></div><div class="line">while [ &quot;$a&quot; -le &quot;$LIMIT&quot; ]</div><div class="line">do</div><div class="line">  a=$(($a+1))</div><div class="line"></div><div class="line">  if [ &quot;$a&quot; -gt 2 ]</div><div class="line">  then</div><div class="line">    break  # 将会跳出整个循环.</div><div class="line">  fi</div><div class="line"></div><div class="line">  echo -n &quot;$a &quot;</div><div class="line">done</div><div class="line"></div><div class="line">echo; echo; echo</div><div class="line"></div><div class="line">exit 0</div></pre></td></tr></table></figure>
<h3 id="2-continue"><a href="#2-continue" class="headerlink" title="2.continue"></a>2.continue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">LIMIT=19  # 上限</div><div class="line"></div><div class="line">echo</div><div class="line">echo &quot;Printing Numbers 1 through 20 (but not 3 and 11).&quot;</div><div class="line"></div><div class="line">a=0</div><div class="line"></div><div class="line">while [ $a -le &quot;$LIMIT&quot; ]</div><div class="line">do</div><div class="line">  a=$(($a+1))</div><div class="line"></div><div class="line">  if [ &quot;$a&quot; -eq 3 ] || [ &quot;$a&quot; -eq 11 ]  # 除了3和11.</div><div class="line">  then</div><div class="line">    continue      # 跳过本次循环剩余的语句.</div><div class="line">  fi</div><div class="line"></div><div class="line">  echo -n &quot;$a &quot;   # 在$a等于3和11的时候，这句将不会执行.</div><div class="line">done</div><div class="line"></div><div class="line">echo; echo</div><div class="line"></div><div class="line">echo Printing Numbers 1 through 20, but something happens after 2.</div><div class="line">exit 0</div></pre></td></tr></table></figure>
<h2 id="测试与分支"><a href="#测试与分支" class="headerlink" title="测试与分支"></a>测试与分支</h2><h3 id="1-case-in-esac"><a href="#1-case-in-esac" class="headerlink" title="1.case (in) / esac"></a>1.case (in) / esac</h3><p>在shell中的case结构与C/C++中的switch结构是相同的。它允许通过判断来选择代码块中多 条路径中的一条。它的作用和多个if/then/else语句的作用相同，是它们的简化结构，特别 适用于创建菜单。case块以esac（case的反向拼写）结尾。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"># 测试字符串范围.</div><div class="line"></div><div class="line">echo; echo &quot;Hit a key, then hit return.&quot;</div><div class="line">read Keypress</div><div class="line"></div><div class="line">case &quot;$Keypress&quot; in</div><div class="line">[[:lower:]]   ) echo &quot;Lowercase letter&quot;;;</div><div class="line">[[:upper:]]   ) echo &quot;Uppercase letter&quot;;;</div><div class="line">[0-9]         ) echo &quot;Digit&quot;;;</div><div class="line">*             ) echo &quot;Punctuation, whitespace, or other&quot;;;</div><div class="line">esac      #  允许字符串的范围出现在[中括号]中,</div><div class="line">#+ 或者出现在POSIX风格的[[双中括号中.</div><div class="line"></div><div class="line">#  在这个例子的第一个版本中,</div><div class="line">#+ 测试大写和小写字符串的工作使用的是</div><div class="line">#+ [a-z] 和 [A-Z].</div><div class="line">#  这种用法在某些特定场合的或某些Linux发行版中不能够正常工作.</div><div class="line">#  POSIX 的风格更具可移植性.</div><div class="line"></div><div class="line">exit 0</div></pre></td></tr></table></figure>
<h3 id="2-select"><a href="#2-select" class="headerlink" title="2.select"></a>2.select</h3><p>select结构是建立菜单的另一种工具，这种结构是从ksh中引入的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">PS3=&apos;Choose your favorite vegetable: &apos; # 设置提示符字串.</div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line">select vegetable in &quot;beans&quot; &quot;carrots&quot; &quot;potatoes&quot; &quot;onions&quot; &quot;rutabagas&quot;</div><div class="line">do</div><div class="line">  echo</div><div class="line">  echo &quot;Your favorite veggie is $vegetable.&quot;</div><div class="line">  echo &quot;Yuck!&quot;</div><div class="line">  echo</div><div class="line">  break  </div><div class="line">done</div><div class="line"></div><div class="line">exit 0</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;循环&quot;&gt;&lt;a href=&quot;#循环&quot; class=&quot;headerlink&quot; title=&quot;循环&quot;&gt;&lt;/a&gt;循环&lt;/h2&gt;&lt;h3 id=&quot;1-for循环&quot;&gt;&lt;a href=&quot;#1-for循环&quot; class=&quot;headerlink&quot; title=&quot;1.for循环&quot;&gt;&lt;/
    
    </summary>
    
      <category term="Shell" scheme="http://yoursite.com/categories/Shell/"/>
    
    
      <category term="Bash" scheme="http://yoursite.com/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>vi基础</title>
    <link href="http://yoursite.com/2017/02/10/vi%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2017/02/10/vi基础/</id>
    <published>2017-02-10T02:23:52.000Z</published>
    <updated>2017-02-10T02:28:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vi基础操作"><a href="#vi基础操作" class="headerlink" title="vi基础操作"></a>vi基础操作</h2><h3 id="1、vi的基本概念"><a href="#1、vi的基本概念" class="headerlink" title="1、vi的基本概念"></a>1、vi的基本概念</h3><p>　　 基本上vi分为三种状态，分别是命令模式、插入模式、末行模式（last line mode）</p>
<h3 id="2、-插入模式"><a href="#2、-插入模式" class="headerlink" title="2、 插入模式"></a>2、 插入模式</h3><p>　　 只有在【插入模式】中，才可以进行文字输入，可以按「ESC」键可回到命令模式。</p>
<h3 id="3、-末行模式（last-line-mode）"><a href="#3、-末行模式（last-line-mode）" class="headerlink" title="3、 末行模式（last line mode）"></a>3、 末行模式（last line mode）</h3><p>　　 在命令模式下，输入：冒号，可以进入末行模式，</p>
<p>此时，可以通过命令，将文件保存或退出vi，</p>
<p>也可以设置编辑环境，如寻找字符串、列出行号……等。</p>
<h3 id="4、vi的基本操作"><a href="#4、vi的基本操作" class="headerlink" title="4、vi的基本操作"></a>4、vi的基本操作</h3><h3 id="5、-进入vi"><a href="#5、-进入vi" class="headerlink" title="5、 进入vi"></a>5、 进入vi</h3><p>　　 在终端输入vi或vi 文件名，就进入vi全屏幕编辑画面</p>
<p>进入vi之后，首先处于「命令行模式」，按下i键,可进入到「插入模式」</p>
<h3 id="6、-切换至插入模式"><a href="#6、-切换至插入模式" class="headerlink" title="6、 切换至插入模式"></a>6、 切换至插入模式</h3><p>　　在「命令行模式」下按一下字母「i」就可以进入「插入模式」，这时才可开始输入文字。</p>
<p>编辑好内容后,想要保存的话,要先按一下「ESC」键,回到「命令行模式」先</p>
<h3 id="7、-退出vi及保存文件"><a href="#7、-退出vi及保存文件" class="headerlink" title="7、 退出vi及保存文件"></a>7、 退出vi及保存文件</h3><p>　　 当处于【插入模式】时，要先按「ESC」键,回到「命令行模式」</p>
<p>然后，在「命令行模式」下，按一下「：」冒号键进入「Last line mode」</p>
<p>此时,才可以执行相应的保存，退出等命令</p>
<p>: w 2.txt    将刚才编写的文本,以2.txt名称 写入磁盘，即保存到当前目录下</p>
<p>: wq  (写到磁盘并退出vi)<br>: q! (强制退出vi，并且不存盘)</p>
<h3 id="8、命令行模式-下的命令-即功能键"><a href="#8、命令行模式-下的命令-即功能键" class="headerlink" title="8、命令行模式 下的命令,即功能键"></a>8、命令行模式 下的命令,即功能键</h3><p>　　 按「i」切换进入插入模式，是从光标的前一个位置,开始输入文字；</p>
<p> 　　按「a」进入插入模式，是从目前光标的下一个位置,开始输入文字；</p>
<p>按「o」进入插入模式后，是插入新的一行，并从新的一行的行首开始输入文字。</p>
<h3 id="9、-从插入模式回到（切换）为命令行模式"><a href="#9、-从插入模式回到（切换）为命令行模式" class="headerlink" title="9、 从插入模式回到（切换）为命令行模式"></a>9、 从插入模式回到（切换）为命令行模式</h3><p>　　按「ESC」键</p>
<h3 id="10、-在命令模式下-移动光标"><a href="#10、-在命令模式下-移动光标" class="headerlink" title="10、 在命令模式下,移动光标"></a>10、 在命令模式下,移动光标</h3><p> 　　vi可以直接用键盘上的光标来上下左右移动，</p>
<p>vi也可以用小写英文字母「h」、「j」、「k」、「l」</p>
<p>分别控制光标左、下、上、右移一格。</p>
<p>　　按「ctrl」+「b」：屏幕往“后”移动一页,即翻到上页pageUp。</p>
<p>　　按「ctrl」+「f」：屏幕往“前”移动一页,即翻到上页pageDown。</p>
<p>　　按「ctrl」+「u」：屏幕往“上”移动半页。</p>
<p>　　按「ctrl」+「d」：屏幕往“下”移动半页。</p>
<p>　　按数字「0」：光标移到所在行的开头。</p>
<p>　　按「g」：移动到文章的最前面。</p>
<p>按「G」：移动到文章的最后面。</p>
<p>　　按「$」：移动到光标所在行的“行尾”。</p>
<p>　　按「^」：移动到光标所在行的“行首”</p>
<p>　　按「w」：光标跳到下个单词的开头</p>
<p>　　按「e」：光标跳到下个单词的结尾</p>
<p>　　按「b」：光标回到前个单词的开头</p>
<h3 id="11、-删除文字"><a href="#11、-删除文字" class="headerlink" title="11、 删除文字"></a>11、 删除文字</h3><p>　　「x」：每按一次，删除光标所在位置的“后面”一个字符。</p>
<p>　　「X」：大写的X，每按一次，删除光标所在位置的“前面”一个字符。</p>
<p>　　「dd」：删除光标所在行。</p>
<p>　　「#dd」：从光标所在行开始删除#行,#代表任何数字</p>
<h3 id="12、-复制和粘贴"><a href="#12、-复制和粘贴" class="headerlink" title="12、 复制和粘贴"></a>12、 复制和粘贴</h3><p>　　「yw」：将光标所在之处到字尾的字符复制到缓冲区中。</p>
<p>　　「#yw」：复制#个字到缓冲区</p>
<p>　　「yy」：复制光标所在行到缓冲区。</p>
<p>　　「#yy」：例如，「6yy」表示拷贝从光标所在的该行“往下数”6行文字。</p>
<p>　　「p」：将缓冲区内的字符粘贴到光标所在位置。注意：所有与“y”有关的复制命令都<br>必须与“p”配合才能完成复制与粘贴功能。</p>
<h3 id="13、-撤销上一次操作"><a href="#13、-撤销上一次操作" class="headerlink" title="13、 撤销上一次操作"></a>13、 撤销上一次操作</h3><p>　　「u」：如果误执行一个命令，可以马上按下「u」，撤销上一个操作。按多次“u”<br>可以执行多次回复。</p>
<h3 id="14、-跳至指定的行"><a href="#14、-跳至指定的行" class="headerlink" title="14、 跳至指定的行"></a>14、 跳至指定的行</h3><p>　　「ctrl」+「g」列出光标所在行的行号。</p>
<p>　　「#G」：例如，「4G」，表示移动光标至文章的第4行行首。</p>
<h3 id="15、Last-line-mode下命令简介"><a href="#15、Last-line-mode下命令简介" class="headerlink" title="15、Last line mode下命令简介"></a>15、Last line mode下命令简介</h3><p>　　在使用「last line mode」之前，请记住先按「ESC」键确定您已经处于「command m<br>ode」下后，再按「：」冒号即可进入「last line mode」。<br>列出行号「set nu」：输入「set nu」后，会在文件中的每一行前面列出行号。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;vi基础操作&quot;&gt;&lt;a href=&quot;#vi基础操作&quot; class=&quot;headerlink&quot; title=&quot;vi基础操作&quot;&gt;&lt;/a&gt;vi基础操作&lt;/h2&gt;&lt;h3 id=&quot;1、vi的基本概念&quot;&gt;&lt;a href=&quot;#1、vi的基本概念&quot; class=&quot;headerlink
    
    </summary>
    
      <category term="vi" scheme="http://yoursite.com/categories/vi/"/>
    
    
      <category term="Bash" scheme="http://yoursite.com/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>ch8-操作符</title>
    <link href="http://yoursite.com/2017/02/09/ch8-%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://yoursite.com/2017/02/09/ch8-操作符/</id>
    <published>2017-02-09T09:10:22.000Z</published>
    <updated>2017-02-10T09:12:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><h3 id="1-变量赋值"><a href="#1-变量赋值" class="headerlink" title="1.变量赋值"></a>1.变量赋值</h3><p>= 通用赋值操作符，可用于算术和字符串赋值。</p>
<p>var=27<br>category=minerals  # 在”=”之后是不允许出现空白字符的.<br>不要混淆=赋值操作符与 = 测试操作符。也正是因为这一点，在bash里面测试操作符也常写作==，但这可能在其它shell中是不允许的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#    = 在这里是测试操作符</div><div class="line"></div><div class="line">if [ &quot;$string1&quot; = &quot;$string2&quot; ]</div><div class="line"># if [ &quot;X$string1&quot; = &quot;X$string2&quot; ] 是一种更安全的做法,</div><div class="line"># 这样可以防止两个变量中的一个为空所产生的错误.</div><div class="line"># (字符&quot;X&quot;作为前缀在等式两边是可以相互抵消的.)</div><div class="line">then</div><div class="line">  command</div><div class="line">fi</div></pre></td></tr></table></figure>
<h2 id="算术操作符"><a href="#算术操作符" class="headerlink" title="算术操作符"></a>算术操作符</h2><h3 id="1-简单算术操作符"><a href="#1-简单算术操作符" class="headerlink" title="1.简单算术操作符"></a>1.简单算术操作符</h3><p>操作符    说明<br>+    加法计算</p>
<p>-    减法计算</p>
<p>*    乘法计算</p>
<p>/    除法计算</p>
<p>**    幂运算</p>
<p>%    模运算，或者是求余运算（返回一次除法运算的余数）</p>
<h3 id="2-求最大公约数"><a href="#2-求最大公约数" class="headerlink" title="2.求最大公约数"></a>2.求最大公约数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"># gcd.sh: 最大公约数</div><div class="line"></div><div class="line"></div><div class="line">#  两个整数的&quot;最大公约数&quot; (gcd),</div><div class="line">#+ 就是两个整数所能够同时整除的最大的数.</div><div class="line"></div><div class="line">#  Euclid算法采用连续除法.</div><div class="line">#  在每一次循环中,</div><div class="line">#+ 被除数 &lt;---  除数</div><div class="line">#+ 除数 &lt;---  余数</div><div class="line">#+ 直到 余数 = 0.</div><div class="line">#+ 在最后一次循环中, gcd = 被除数.</div><div class="line">#</div><div class="line"></div><div class="line"># ------------------------------------------------------</div><div class="line"># 参数检查</div><div class="line">ARGS=2</div><div class="line">E_BADARGS=65</div><div class="line"></div><div class="line">if [ $# -ne &quot;$ARGS&quot; ]</div><div class="line">then</div><div class="line"> echo &quot;Usage: `basename $0` first-number second-number&quot;</div><div class="line"> exit $E_BADARGS</div><div class="line">fi</div><div class="line"># ------------------------------------------------------</div><div class="line"></div><div class="line"></div><div class="line">gcd ()</div><div class="line">&#123;</div><div class="line"></div><div class="line"> dividend=$1                    #  随意赋值.</div><div class="line"> divisor=$2                     #+ 在这里, 哪个值给的大都没关系.</div><div class="line">                                </div><div class="line"></div><div class="line"> remainder=1                    #  如果在循环中使用了未初始化的变量,</div><div class="line">                                #+ 那么在第一次循环中,</div><div class="line">                                #+ 它将会产生一个错误消息.</div><div class="line"></div><div class="line"> until [ &quot;$remainder&quot; -eq 0 ]</div><div class="line"> do</div><div class="line">   let &quot;remainder = $dividend % $divisor&quot;</div><div class="line">   dividend=$divisor            # 现在使用两个最小的数来重复.</div><div class="line">   divisor=$remainder</div><div class="line"> done                           </div><div class="line"></div><div class="line">&#125;                                # Last $dividend is the gcd.</div><div class="line"></div><div class="line"></div><div class="line">gcd $1 $2</div><div class="line"></div><div class="line">echo; echo &quot;GCD of $1 and $2 = $dividend&quot;; echo</div><div class="line"># 或者 echo -e &quot;\nGCD of $1 and $2 = $dividend\n&quot;</div><div class="line"></div><div class="line"></div><div class="line"># Exercise :</div><div class="line"># --------</div><div class="line">#  检查传递进来的命令行参数来确保它们都是整数.</div><div class="line">#+ 如果不是整数, 那就给出一个适当的错误消息并退出脚本.</div><div class="line"></div><div class="line">exit 0</div></pre></td></tr></table></figure>
<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div></pre></td></tr></table></figure>
<h3 id="3-其他算术操作符"><a href="#3-其他算术操作符" class="headerlink" title="3.其他算术操作符"></a>3.其他算术操作符</h3><p>+= “加-等于”（把变量的值增加一个常量然后再把结果赋给变量）</p>
<p>let “var += 5” # var变量的值会在原来的基础上加5<br>-= “减-等于”（把变量的值减去一个常量然后再把结果赋给变量） *= “乘-等于”（先把变量的值乘以一个常量的值，然后再把结果赋给变量）</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;赋值&quot;&gt;&lt;a href=&quot;#赋值&quot; class=&quot;headerlink&quot; title=&quot;赋值&quot;&gt;&lt;/a&gt;赋值&lt;/h2&gt;&lt;h3 id=&quot;1-变量赋值&quot;&gt;&lt;a href=&quot;#1-变量赋值&quot; class=&quot;headerlink&quot; title=&quot;1.变量赋值&quot;&gt;&lt;/a&gt;1
    
    </summary>
    
      <category term="Shell" scheme="http://yoursite.com/categories/Shell/"/>
    
    
      <category term="Bash" scheme="http://yoursite.com/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>ch7-条件判断</title>
    <link href="http://yoursite.com/2017/02/09/ch7-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD/"/>
    <id>http://yoursite.com/2017/02/09/ch7-条件判断/</id>
    <published>2017-02-09T07:14:53.000Z</published>
    <updated>2017-02-10T09:11:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="条件测试结构"><a href="#条件测试结构" class="headerlink" title="条件测试结构"></a>条件测试结构</h2><h3 id="1-if-then-结构"><a href="#1-if-then-结构" class="headerlink" title="1.if/then 结构"></a>1.if/then 结构</h3><p>if/then 结构用来判断命令列表的退出状态码是否为 0，因为0表示成功，如果成功的话，这里应该那么就执行接下来的一个或多个命令。</p>
<p>注意： 这里与C语言的等其它语言不同，不能直接使用0或者1作为判断条件，而应该以false，true代替。以其它大多数语言相反的true返回的是0,false返回的是1</p>
<p>有一个专有命令 [ （左中括号，特殊字符）。这个命令与test命令等价，由于效率上的考虑，bash将它作为一个内建命令。</p>
<p>注意： 由于bash的语法检查机制，如果在条件测试时只使用一个[将会出现一个错误提示，为了避免这个问题，我们通常将使用一对方括号包含条件测试[]</p>
<p>在版本2.02的Bash中, 引入了 “[[ … ]]” 扩展测试命令，[[ 是一个关键字，并不是一个命令。</p>
<p>if 命令能够测试任何命令，并不仅仅是中括号中的条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line"># 逐字节比较a b两个文件是否相同</div><div class="line">if cmp a b &amp;&gt; /dev/null  # 禁止输出.</div><div class="line">then echo &quot;Files a and b are identical.&quot;</div><div class="line">else echo &quot;Files a and b differ.&quot;</div><div class="line">fi</div><div class="line"></div><div class="line"># 非常有用的&quot;if-grep&quot;结构:</div><div class="line"># ------------------------</div><div class="line">if grep -q Bash file</div><div class="line">then echo &quot;File contains at least one occurrence of Bash.&quot;</div><div class="line">fi</div><div class="line"></div><div class="line">word=Linux</div><div class="line">letter_sequence=inu</div><div class="line">if echo &quot;$word&quot; | grep -q &quot;$letter_sequence&quot;</div><div class="line"># &quot;-q&quot; 选项是用来禁止输出的.</div><div class="line">then</div><div class="line"> echo &quot;$letter_sequence found in $word&quot;</div><div class="line">else</div><div class="line"> echo &quot;$letter_sequence not found in $word&quot;</div><div class="line">fi</div><div class="line"></div><div class="line"># 将打印Command failed</div><div class="line">if COMMAND_WHOSE_EXIT_STATUS_IS_0_UNLESS_ERROR_OCCURRED</div><div class="line">then echo &quot;Command succeeded.&quot;</div><div class="line">else echo &quot;Command failed.&quot;</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div></pre></td></tr></table></figure>
<p>2.多级比较（应注意与嵌套条件分支区分）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line"># 这里应该理解为子if/then当做一个整体作为测试条件</div><div class="line">if echo &quot;Next *if* is part of the comparison for the first *if*.&quot;</div><div class="line">   if [[ $comparison = &quot;integer&quot; ]]</div><div class="line">     then (( a &lt; b )) # (( 算数表达式 ))， 用作算数运算</div><div class="line">   else</div><div class="line">     [[ $a &lt; $b ]]</div><div class="line">   fi</div><div class="line">then</div><div class="line"> echo &apos;$a is less than $b&apos;</div><div class="line">fi</div><div class="line">注意： ((...))和let...如果运算结果为非0，该语句退出码为0，否则为1；[[...]]是作为一个单独的语句并且会返回一个退出码</div></pre></td></tr></table></figure>
<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div></pre></td></tr></table></figure>
<h3 id="3-真假判断"><a href="#3-真假判断" class="headerlink" title="3.真假判断"></a>3.真假判断</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">#  小技巧:</div><div class="line">#  如果你不能够确定一个特定的条件该如何进行判断,</div><div class="line">#+ 那么就使用if-test结构.</div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line">echo &quot;Testing \&quot;0\&quot;&quot;</div><div class="line">if [ 0 ]      # zero</div><div class="line">then</div><div class="line">  echo &quot;0 is true.&quot;</div><div class="line">else</div><div class="line">  echo &quot;0 is false.&quot;</div><div class="line">fi            # 0 为真.</div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line">echo &quot;Testing \&quot;1\&quot;&quot;</div><div class="line">if [ 1 ]      # one</div><div class="line">then</div><div class="line">  echo &quot;1 is true.&quot;</div><div class="line">else</div><div class="line">  echo &quot;1 is false.&quot;</div><div class="line">fi            # 1 为真.</div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line">echo &quot;Testing \&quot;-1\&quot;&quot;</div><div class="line">if [ -1 ]     # 负1</div><div class="line">then</div><div class="line">  echo &quot;-1 is true.&quot;</div><div class="line">else</div><div class="line">  echo &quot;-1 is false.&quot;</div><div class="line">fi            # -1 为真.</div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line">echo &quot;Testing \&quot;NULL\&quot;&quot;</div><div class="line">if [ ]        # NULL (空状态)</div><div class="line">then</div><div class="line">  echo &quot;NULL is true.&quot;</div><div class="line">else</div><div class="line">  echo &quot;NULL is false.&quot;</div><div class="line">fi            # NULL 为假.</div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line">echo &quot;Testing \&quot;xyz\&quot;&quot;</div><div class="line">if [ xyz ]    # 字符串</div><div class="line">then</div><div class="line">  echo &quot;Random string is true.&quot;</div><div class="line">else</div><div class="line">  echo &quot;Random string is false.&quot;</div><div class="line">fi            # 随便的一串字符为真.</div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line">echo &quot;Testing \&quot;\$xyz\&quot;&quot;</div><div class="line">if [ $xyz ]   # 判断$xyz是否为null, 但是...</div><div class="line">              # 这只是一个未初始化的变量.</div><div class="line">then</div><div class="line">  echo &quot;Uninitialized variable is true.&quot;</div><div class="line">else</div><div class="line">  echo &quot;Uninitialized variable is false.&quot;</div><div class="line">fi            # 未定义的初始化为假.</div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line">echo &quot;Testing \&quot;-n \$xyz\&quot;&quot;</div><div class="line">if [ -n &quot;$xyz&quot; ]            # 更加正规的条件检查.</div><div class="line">then</div><div class="line">  echo &quot;Uninitialized variable is true.&quot;</div><div class="line">else</div><div class="line">  echo &quot;Uninitialized variable is false.&quot;</div><div class="line">fi            # 未初始化的变量为假.</div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line"></div><div class="line">xyz=          # 初始化了, 但是赋null值.</div><div class="line"></div><div class="line">echo &quot;Testing \&quot;-n \$xyz\&quot;&quot;</div><div class="line">if [ -n &quot;$xyz&quot; ]</div><div class="line">then</div><div class="line">  echo &quot;Null variable is true.&quot;</div><div class="line">else</div><div class="line">  echo &quot;Null variable is false.&quot;</div><div class="line">fi            # null变量为假.</div><div class="line"></div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line"></div><div class="line"># 什么时候&quot;false&quot;为真?</div><div class="line"></div><div class="line">echo &quot;Testing \&quot;false\&quot;&quot;</div><div class="line">if [ &quot;false&quot; ]              #  看起来&quot;false&quot;只不过是一个字符串而已.</div><div class="line">then</div><div class="line">  echo &quot;\&quot;false\&quot; is true.&quot; #+ 并且条件判断的结果为真.</div><div class="line">else</div><div class="line">  echo &quot;\&quot;false\&quot; is false.&quot;</div><div class="line">fi            # &quot;false&quot; 为真.</div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line">echo &quot;Testing \&quot;\$false\&quot;&quot;  # 再来一个, 未初始化的变量.</div><div class="line">if [ &quot;$false&quot; ]</div><div class="line">then</div><div class="line">  echo &quot;\&quot;\$false\&quot; is true.&quot;</div><div class="line">else</div><div class="line">  echo &quot;\&quot;\$false\&quot; is false.&quot;</div><div class="line">fi            # &quot;$false&quot; 为假.</div><div class="line">              # 现在, 我们得到了预期的结果.</div><div class="line"></div><div class="line">#  如果我们测试以下为初始化的变量&quot;$true&quot;会发生什么呢?</div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line">exit 0</div></pre></td></tr></table></figure>
<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div></pre></td></tr></table></figure>
<h3 id="4-结构"><a href="#4-结构" class="headerlink" title="4.(( )) 结构"></a>4.(( )) 结构</h3><p>(( )) 结构扩展并计算一个算术表达式的值。如果表达式的结果为0，那么返回的退出状态码为1，或者是”假”。而一个非零值的表达式所返回的退出状态码将为0，或者是”true”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"># 算术测试.</div><div class="line"></div><div class="line"># (( ... ))结构可以用来计算并测试算术表达式的结果.</div><div class="line"># 退出状态将会与[ ... ]结构完全相反!</div><div class="line"></div><div class="line">(( 0 ))</div><div class="line">echo &quot;Exit status of \&quot;(( 0 ))\&quot; is $?.&quot;         # 1</div><div class="line"></div><div class="line">(( 1 ))</div><div class="line">echo &quot;Exit status of \&quot;(( 1 ))\&quot; is $?.&quot;         # 0</div><div class="line"></div><div class="line">(( 5 &gt; 4 ))                                      # 真</div><div class="line">echo &quot;Exit status of \&quot;(( 5 &gt; 4 ))\&quot; is $?.&quot;     # 0</div><div class="line"></div><div class="line">(( 5 &gt; 9 ))                                      # 假</div><div class="line">echo &quot;Exit status of \&quot;(( 5 &gt; 9 ))\&quot; is $?.&quot;     # 1</div><div class="line"></div><div class="line">(( 5 - 5 ))                                      # 0</div><div class="line">echo &quot;Exit status of \&quot;(( 5 - 5 ))\&quot; is $?.&quot;     # 1</div><div class="line"></div><div class="line">(( 5 / 4 ))                                      # 除法也可以.</div><div class="line">echo &quot;Exit status of \&quot;(( 5 / 4 ))\&quot; is $?.&quot;     # 0</div><div class="line"></div><div class="line">(( 1 / 2 ))                                      # 除法的计算结果 &lt; 1.</div><div class="line">echo &quot;Exit status of \&quot;(( 1 / 2 ))\&quot; is $?.&quot;     # 截取之后的结果为 0.</div><div class="line">                                                # 1</div><div class="line"></div><div class="line">(( 1 / 0 )) 2&gt;/dev/null                          # 除数为0, 非法计算.</div><div class="line">#           ^^^^^^^^^^^</div><div class="line">echo &quot;Exit status of \&quot;(( 1 / 0 ))\&quot; is $?.&quot;     # 1</div><div class="line"></div><div class="line"># &quot;2&gt;/dev/null&quot;起了什么作用?</div><div class="line"># 如果这句被删除会怎样?</div><div class="line"># 尝试删除这句, 然后在运行这个脚本.</div><div class="line"></div><div class="line">exit 0</div></pre></td></tr></table></figure>
<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div></pre></td></tr></table></figure>
<h2 id="文件测试操作符"><a href="#文件测试操作符" class="headerlink" title="文件测试操作符"></a>文件测试操作符</h2><h3 id="1-操作符列举"><a href="#1-操作符列举" class="headerlink" title="1.操作符列举"></a>1.操作符列举</h3><p>操作符    说明<br>-e    文件存在</p>
<p>-a    文件存在，这个选项的效果与 -e 相同。但是它已经被“弃用”了，并且不鼓励使用。</p>
<p>-f    表示这个文件是一个一般文件（并不是目录或者设备文件）</p>
<p>-s    文件大小不为零</p>
<p>-d    表示这是一个目录</p>
<p>-b    表示这是一个块设备（软盘，光驱，等等）</p>
<p>-c    表示这是一个字符设备（键盘，modem，声卡，等等）</p>
<p>-p    这个文件是一个管道</p>
<p>-h    这是一个符号链接</p>
<p>-L    这是一个符号链接</p>
<p>-S    表示这是一个socket</p>
<p>-t    文件（描述符）被关联到一个终端设备上，这个测试选项一般被用来检测脚本中的 stdin([ -t 0 ]) 或者 stdout([ -t 1 ])是否来自于一个终端<br>-r    文件是否具有可读权限（指的是正在运行这个测试命令的用户是否具有读权限）</p>
<p>-w    文件是否具有可写权限（指的是正在运行这个测试命令的用户是否具有写权限）</p>
<p>-x    文件是否具有可执行权限（指的是正在运行这个测试命令的用户是否具有可执行权限）</p>
<p>-g    set-group-id(sgid)标记被设置到文件或目录上</p>
<p>-k    设置粘贴位</p>
<p>-O    判断你是否是文件的拥有者</p>
<p>-G    文件的group-id是否与你的相同</p>
<p>-N    从文件上一次被读取到现在为止, 文件是否被修改过</p>
<p>f1 -nt f2    文件f1比文件f2新</p>
<p>f1 -ot f2    文件f1比文件f2旧</p>
<p>f1 -ef f2    文件f1和文件f2是相同文件的硬链接</p>
<p>!    “非”，反转上边所有测试的结果（如果没给出条件，那么返回真）</p>
<h3 id="2-举例"><a href="#2-举例" class="headerlink" title="2.举例"></a>2.举例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash[ $# -eq 0 ] &amp;&amp; directorys=`pwd` || directorys=$@for directory in `ls $directorys`; do   if [ -d &quot;$directorys$directory&quot; ]  then echo &quot;dir: + $directory&quot;  else      echo &quot;$directory is not a directory&quot;   fidoneexit 0</div></pre></td></tr></table></figure>
<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div></pre></td></tr></table></figure>
<h2 id="二元比较操作符"><a href="#二元比较操作符" class="headerlink" title="二元比较操作符"></a>二元比较操作符</h2><h3 id="1-整数比较"><a href="#1-整数比较" class="headerlink" title="1.整数比较"></a>1.整数比较</h3><p>-eq 等于</p>
<p>if [ “$a” -eq “$b” ]<br>-ne 不等于</p>
<p>if [ “$a” -ne “$b” ]<br>-gt 大于</p>
<p>if [ “$a” -gt “$b” ]<br>-ge 大于等于</p>
<p>if [ “$a” -ge “$b” ]<br>-lt 小于</p>
<p>if [ “$a” -lt “$b” ]<br>-le 小于等于</p>
<p>if [ “$a” -le “$b” ]<br>&lt; 小于(在双括号中使用)</p>
<p>((“$a” &lt; “$b”))<br>&lt;= 小于等于(在双括号中使用)</p>
<p>((“$a” &lt;= “$b”))<br>大于(在双括号中使用)<br>((“$a” &gt; “$b”))<br>= 大于等于(在双括号中使用)<br>((“$a” &gt;= “$b”))<br>2.字符串比较</p>
<p>= 等于</p>
<p>if [ “$a” = “$b” ]<br>== 等于，与=等价</p>
<p>if [ “$a” == “$b” ]<br>!= 不等号</p>
<p>if [ “$a” != “$b” ]<br>&lt; 小于，按照ASCII字符进行排序</p>
<p>if [[ “$a” &lt; “$b” ]]<br>if [ “$a” \&lt; “$b” ]<br>注意”&lt;”使用在[ ]结构中的时候需要被转义<br>大于，按照ASCII字符进行排序<br>if [[ “$a” &gt; “$b” ]]<br>if [ “$a” > “$b” ]<br>注意“&gt;”使用在[ ]结构中的时候需要被转义<br>-z 字符串为“null”，意思就是字符串长度为零 -n 字符串不为“null”</p>
<h3 id="3-算术比较与字符串比较"><a href="#3-算术比较与字符串比较" class="headerlink" title="3.算术比较与字符串比较"></a>3.算术比较与字符串比较</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">a=4</div><div class="line">b=5</div><div class="line"></div><div class="line">#  这里的&quot;a&quot;和&quot;b&quot;既可以被认为是整型也可被认为是字符串.</div><div class="line">#  这里在算术比较与字符串比较之间是容易让人产生混淆,</div><div class="line">#+ 因为Bash变量并不是强类型的.</div><div class="line"></div><div class="line">#  Bash允许对于变量进行整形操作与比较操作.</div><div class="line">#+ 但前提是变量中只能包含数字字符.</div><div class="line">#  不管怎么样, 还是要小心.</div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line">if [ &quot;$a&quot; -ne &quot;$b&quot; ]</div><div class="line">then</div><div class="line"> echo &quot;$a is not equal to $b&quot;</div><div class="line"> echo &quot;(arithmetic comparison)&quot;</div><div class="line">fi</div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line">if [ &quot;$a&quot; != &quot;$b&quot; ]</div><div class="line">then</div><div class="line"> echo &quot;$a is not equal to $b.&quot;</div><div class="line"> echo &quot;(string comparison)&quot;</div><div class="line"> #     &quot;4&quot;  != &quot;5&quot;</div><div class="line"> # ASCII 52 != ASCII 53</div><div class="line">fi</div><div class="line"></div><div class="line"># 在这个特定的例子中, &quot;-ne&quot;和&quot;!=&quot;都可以.</div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line">exit 0</div></pre></td></tr></table></figure>
<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div></pre></td></tr></table></figure>
<h3 id="4-检查字符串是否为null"><a href="#4-检查字符串是否为null" class="headerlink" title="4.检查字符串是否为null"></a>4.检查字符串是否为null</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">#  str-test.sh: 检查null字符串和未引用的字符串,</div><div class="line"></div><div class="line"># 使用   if [ ... ]</div><div class="line"></div><div class="line"></div><div class="line"># 如果字符串并没有被初始化, 那么它里面的值未定义.</div><div class="line"># 这种状态被称为&quot;null&quot; (注意这与零值不同).</div><div class="line"></div><div class="line">if [ -n $string1 ]    # $string1 没有被声明和初始化.</div><div class="line">then</div><div class="line"> echo &quot;String \&quot;string1\&quot; is not null.&quot;</div><div class="line">else  </div><div class="line"> echo &quot;String \&quot;string1\&quot; is null.&quot;</div><div class="line">fi  </div><div class="line"># 错误的结果.</div><div class="line"># 显示$string1为非null, 虽然这个变量并没有被初始化.</div><div class="line"></div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line"></div><div class="line"># 让我们再试一下.</div><div class="line"></div><div class="line">if [ -n &quot;$string1&quot; ]  # 这次$string1被引号扩起来了.</div><div class="line">then</div><div class="line"> echo &quot;String \&quot;string1\&quot; is not null.&quot;</div><div class="line">else  </div><div class="line"> echo &quot;String \&quot;string1\&quot; is null.&quot;</div><div class="line">fi                    # 注意一定要将引用的字符放到中括号结构中!</div><div class="line"></div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line"></div><div class="line">if [ $string1 ]       # 这次, 就一个$string1, 什么都不加.</div><div class="line">then</div><div class="line"> echo &quot;String \&quot;string1\&quot; is not null.&quot;</div><div class="line">else  </div><div class="line"> echo &quot;String \&quot;string1\&quot; is null.&quot;</div><div class="line">fi  </div><div class="line"># 这种情况运行的非常好.</div><div class="line"># [ ] 测试操作符能够独立检查string是否为null.</div><div class="line"># 然而, 使用(&quot;$string1&quot;)是一种非常好的习惯.</div><div class="line">#</div><div class="line">#    if [ $string1 ]    只有一个参数, &quot;]&quot;</div><div class="line">#    if [ &quot;$string1&quot; ]  有两个参数, 一个是空的&quot;$string1&quot;, 另一个是&quot;]&quot;</div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line">string1=initialized</div><div class="line"></div><div class="line">if [ $string1 ]       # 再来, 还是只有$string1, 什么都不加.</div><div class="line">then</div><div class="line"> echo &quot;String \&quot;string1\&quot; is not null.&quot;</div><div class="line">else  </div><div class="line"> echo &quot;String \&quot;string1\&quot; is null.&quot;</div><div class="line">fi  </div><div class="line"># 再来试一下, 给出了正确的结果.</div><div class="line"># 再强调一下, 使用引用的(&quot;$string1&quot;)还是更好一些, 原因我们上边已经说过了.</div><div class="line"></div><div class="line"></div><div class="line">string1=&quot;a = b&quot;</div><div class="line"></div><div class="line">if [ $string1 ]       # 再来, 还是只有$string1, 什么都不加.</div><div class="line">then</div><div class="line"> echo &quot;String \&quot;string1\&quot; is not null.&quot;</div><div class="line">else  </div><div class="line"> echo &quot;String \&quot;string1\&quot; is null.&quot;</div><div class="line">fi  </div><div class="line"># 未引用的&quot;$string1&quot;, 这回给出了错误的结果!</div><div class="line"></div><div class="line">exit 0</div></pre></td></tr></table></figure>
<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div></pre></td></tr></table></figure>
<h3 id="5-zmore"><a href="#5-zmore" class="headerlink" title="5.zmore"></a>5.zmore</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"># zmore</div><div class="line"></div><div class="line">#使用&apos;more&apos;来查看gzip文件</div><div class="line"></div><div class="line">NOARGS=65</div><div class="line">NOTFOUND=66</div><div class="line">NOTGZIP=67</div><div class="line"></div><div class="line">if [ $# -eq 0 ] # 与if [ -z &quot;$1&quot; ]效果相同</div><div class="line">then</div><div class="line"> echo &quot;Usage: `basename $0` filename&quot; &gt;&amp;2</div><div class="line"> # 错误消息输出到stderr.</div><div class="line"> exit $NOARGS</div><div class="line"> # 返回65作为脚本的退出状态的值(错误码).</div><div class="line">fi  </div><div class="line"></div><div class="line">filename=$1</div><div class="line"></div><div class="line">if [ ! -f &quot;$filename&quot; ]   # 将$filename引用起来, 这样允许其中包含空白字符.</div><div class="line">then</div><div class="line"> echo &quot;File $filename not found!&quot; &gt;&amp;2</div><div class="line"> # 错误消息输出到stderr.</div><div class="line"> exit $NOTFOUND</div><div class="line">fi  </div><div class="line"></div><div class="line">if [ $&#123;filename##*.&#125; != &quot;gz&quot; ]</div><div class="line"># 在变量替换中使用中括号结构.</div><div class="line">then</div><div class="line"> echo &quot;File $1 is not a gzipped file!&quot;</div><div class="line"> exit $NOTGZIP</div><div class="line">fi  </div><div class="line"></div><div class="line">zcat $1 | more</div><div class="line"></div><div class="line"># 使用过滤命令&apos;more.&apos;</div><div class="line"># 当然, 如果你愿意, 也可以使用&apos;less&apos;.</div><div class="line"></div><div class="line"></div><div class="line">exit $?   # 脚本将把管道的退出状态作为返回值.</div><div class="line"># 事实上, 也不一定非要加上&quot;exit $?&quot;, 因为在任何情况下,</div><div class="line"># 脚本都会将最后一条命令的退出状态作为返回值.</div></pre></td></tr></table></figure>
<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div></pre></td></tr></table></figure>
<h3 id="6-compound-和-comparison"><a href="#6-compound-和-comparison" class="headerlink" title="6.compound 和 comparison"></a>6.compound 和 comparison</h3><p>-a 逻辑与 exp1 -a exp2 如果表达式 exp1 和 exp2 都为真的话，那么结果为真。</p>
<p>-o 逻辑或 exp1 -o exp2 如果表达式 exp1 和 exp2 中至少有一个为真的话，那么结果为真。</p>
<p>注意：这与Bash中的比较操作符 &amp;&amp; 和 || 非常相像，但是这个两个操作符是用在双中括号结构中的。</p>
<p>[[ condition1 &amp;&amp; condition2 ]]<br>-o和-a操作符一般都是和test命令或者是单中括号结构一起使用的</p>
<p>if [ “$exp1” -a “$exp2” ]</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;条件测试结构&quot;&gt;&lt;a href=&quot;#条件测试结构&quot; class=&quot;headerlink&quot; title=&quot;条件测试结构&quot;&gt;&lt;/a&gt;条件测试结构&lt;/h2&gt;&lt;h3 id=&quot;1-if-then-结构&quot;&gt;&lt;a href=&quot;#1-if-then-结构&quot; class=&quot;head
    
    </summary>
    
      <category term="Shell" scheme="http://yoursite.com/categories/Shell/"/>
    
    
      <category term="Bash" scheme="http://yoursite.com/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>ch6-退出和退出状态码</title>
    <link href="http://yoursite.com/2017/02/08/ch6-%E9%80%80%E5%87%BA%E5%92%8C%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>http://yoursite.com/2017/02/08/ch6-退出和退出状态码/</id>
    <published>2017-02-08T09:46:38.000Z</published>
    <updated>2017-02-10T09:11:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="退出状态码"><a href="#退出状态码" class="headerlink" title="退出状态码"></a>退出状态码</h2><h3 id="1-退出"><a href="#1-退出" class="headerlink" title="1.退出"></a>1.退出</h3><p>exit 被用来结束一个脚本，它也返回一个值，并且这个值会传递给脚本的父进程，父进程会使用这个值做下一步的处理。</p>
<h3 id="2-退出状态码"><a href="#2-退出状态码" class="headerlink" title="2.退出状态码"></a>2.退出状态码</h3><p>每个命令都会返回一个退出状态码（有时候也被称为返回状态）。</p>
<p>成功的命令返回 0，不成功的命令返回非零值，非零值通常都被解释成一个错误码。行为良好的UNIX命令、程序和工具都会返回 0 作为退出码来表示成功，虽然偶尔也会有例外。</p>
<p>同样的，脚本中的函数和脚本本身也会返回退出状态码。在脚本或者是脚本函数中执行的最后的命令会决定退出状态码。在脚本中，exit nnn 命令将会nnn退出码传递给shell（nnn必须是十进制数，范围必须是0-255）。</p>
<p>当脚本以不带参数的exit命令来结束时，脚本的退出状态码就由脚本中最后执行的命令来决定（就是 exit 之前的命令）。</p>
<h3 id="3-一个例子"><a href="#3-一个例子" class="headerlink" title="3.一个例子"></a>3.一个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">echo hello</div><div class="line">echo $?    # 退出状态为0, 因为命令执行成功.</div><div class="line"></div><div class="line">lskdf      # 无效命令.</div><div class="line">echo $?    # 非零的退出状态, 因为命令执行失败.</div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line">exit 113   # 返回113退出状态给shell.</div><div class="line">           # 为了验证这个结果, 可以在脚本结束的地方使用&quot;echo $?&quot;. </div><div class="line"></div><div class="line">#  一般的, &apos;exit 0&apos; 表示成功,</div><div class="line">#+ 而一个非零的退出码表示一个错误, 或者是反常的条件</div></pre></td></tr></table></figure>
<p>$? 指代的是上一条指令的执行结果。</p>
<p>不带参数的 exit 命令与 exit $? 的效果是一样的，甚至脚本的结尾不写 exit 也与前两者的效果相同。</p>
<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div></pre></td></tr></table></figure>
<h2 id="反转一个条件的用法"><a href="#反转一个条件的用法" class="headerlink" title="反转一个条件的用法"></a>反转一个条件的用法</h2><h3 id="1-例子"><a href="#1-例子" class="headerlink" title="1.例子"></a>1.例子</h3><p>! 逻辑“非”操作符，将会反转命令或条件测试的结果，并且这会影响退出状态码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">true  # &quot;true&quot; 是内建命令.</div><div class="line">echo &quot;exit status of \&quot;true\&quot; = $?&quot;     # 0</div><div class="line"></div><div class="line">! true</div><div class="line">echo &quot;exit status of \&quot;! true\&quot; = $?&quot;   # 1</div><div class="line"># 注意: &quot;!&quot; 和指令间需要一个空格</div><div class="line"># 如果一个命令以&apos;!&apos;开头, 那么会启用Bash的历史机制.</div><div class="line"></div><div class="line">true</div><div class="line">!true</div><div class="line"># 这次就没有错误了, 也没有反转结果.</div><div class="line"># 它只是重复了之前的命令(true)，这种语法在个别版本的bash中并不支持</div></pre></td></tr></table></figure>
<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div></pre></td></tr></table></figure>
<p>特定的退出状态码具有保留含义，所以用户不应该在脚本中指定它。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;退出状态码&quot;&gt;&lt;a href=&quot;#退出状态码&quot; class=&quot;headerlink&quot; title=&quot;退出状态码&quot;&gt;&lt;/a&gt;退出状态码&lt;/h2&gt;&lt;h3 id=&quot;1-退出&quot;&gt;&lt;a href=&quot;#1-退出&quot; class=&quot;headerlink&quot; title=&quot;1.退出&quot;
    
    </summary>
    
      <category term="Shell" scheme="http://yoursite.com/categories/Shell/"/>
    
    
      <category term="Bash" scheme="http://yoursite.com/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>ch5-引用和转义</title>
    <link href="http://yoursite.com/2017/02/08/ch5-%E5%BC%95%E7%94%A8%E5%92%8C%E8%BD%AC%E4%B9%89/"/>
    <id>http://yoursite.com/2017/02/08/ch5-引用和转义/</id>
    <published>2017-02-08T08:53:30.000Z</published>
    <updated>2017-02-10T09:11:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h3><p>在一个双引号中通过直接使用变量名的方法来引用变量，一般情况下都是没问题的。这么做将阻止所有在引号中的特殊字符被重新解释(即都被当作普通的字符串)，包括变量名，但是 $、`（后置引用）和 “\”（转义符）$除外。</p>
<p>保留 $ 作为特殊字符的意义是为了能够在双引号中也能够正常的引用变量（”$variable”）。</p>
<p>使用双引号还能够阻止单词分割，即使这个参数包含有空白，单词也不会被分隔开。 如 variable1=”a variable containing five words”</p>
<h3 id="2-举例"><a href="#2-举例" class="headerlink" title="2.举例"></a>2.举例</h3><p>在echo语句中，只有在单词分割或者需要保留空白的时候，才需要把参数用双引号括起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">var=&quot;&apos;(]\\&#123;&#125;\$\&quot;&quot;</div><div class="line">echo $var        # &apos;(]\&#123;&#125;$&quot;</div><div class="line">echo &quot;$var&quot;      # &apos;(]\&#123;&#125;$&quot;     #同上</div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line">IFS=&apos;\&apos;</div><div class="line">echo $var        # &apos;(] &#123;&#125;$&quot;     \ 字符被空白符替换了, 为什么?</div><div class="line">echo &quot;$var&quot;      # &apos;(]\&#123;&#125;$&quot;</div><div class="line">echo &apos;$var&apos;      # $var</div><div class="line"></div><div class="line">exit 0</div></pre></td></tr></table></figure>
<p>IFS(Internal Field Seperator)在Linux的shell中预设的分隔符。IFS是shell脚本中的一个重要概念，在处理文本数据时，它是相当有用的。内部字段分隔符是用于特定用途的定界符。IFS是存储定界符的环境变量，它是当前shell环境使用的默认定界字符串。<br>当我们设置了bash内置变量IFS后，再使用echo输出时，会将所设定的字符用空格去代替。</p>
<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div></pre></td></tr></table></figure>
<p>单引号（’ ‘）操作与双引号基本一样，但是不允许引用变量，因为 $ 的特殊意义将被关闭。</p>
<p>在单引号中，任何特殊字符都按照字面的意思进行解释，除了单引号本身。所以说单引号（全引用）是一种比双引号（部分引用）更严格的引用方法。</p>
<h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>转义是一种引用单个字符的方法。一个前面放上转义符（\）的字符就是告诉shell 这个字符按照字面的意思进行解释，换句话说，就是这个字符失去了它的特殊含义。</p>
<h3 id="2-转义符的含义"><a href="#2-转义符的含义" class="headerlink" title="2.转义符的含义"></a>2.转义符的含义</h3><p>在 echo 命令中：<br>符号说明<br>\n    表示新的一行</p>
<p>\r    表示回车</p>
<p>\t    表示水平制表符</p>
<p>\v    表示垂直制表符</p>
<p>\b    表示后退符</p>
<p>\a    表示”alert”(蜂鸣或者闪烁)</p>
<p>\0xx    转换为八进制的ASCII码, 等价于0xx</p>
<p>\”    表示引号字面的意思，如：</p>
<p>$ echo “\”Hello\”, he said.” # “Hello”, he said.</p>
<p>\$ 表示 $ 本身字面的含义（跟在 \$ 后边的变量名将不能引用变量的值），如：</p>
<p>$ echo “\$variable01”  # 结果是$variable01</p>
<p>\ 表示反斜线字面的意思，如：</p>
<p>$ echo “\“  # 结果是 \</p>
<h3 id="3-一个实例"><a href="#3-一个实例" class="headerlink" title="3.一个实例"></a>3.一个实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">echo &quot;\v\v\v\v&quot;      # 逐字的打印\v\v\v\v.</div><div class="line"># 使用-e选项的&apos;echo&apos;命令来打印转义符.</div><div class="line">echo &quot;=============&quot;</div><div class="line">echo &quot;VERTICAL TABS&quot;</div><div class="line">echo -e &quot;\v\v\v\v&quot;   # 打印4个垂直制表符.</div><div class="line">echo &quot;==============&quot;</div><div class="line"></div><div class="line">echo &quot;QUOTATION MARK&quot;</div><div class="line">echo -e &quot;\042&quot;       # 打印&quot; (引号, 8进制的ASCII 码就是42).</div><div class="line">echo &quot;==============&quot;</div><div class="line"></div><div class="line"># 如果使用$&apos;\X&apos;结构,那-e选项就不必要了.</div><div class="line">echo; echo &quot;NEWLINE AND BEEP&quot;</div><div class="line">echo $&apos;\n&apos;           # 新行.</div><div class="line">echo $&apos;\a&apos;           # 警告(蜂鸣).</div><div class="line"></div><div class="line">echo &quot;===============&quot;</div><div class="line">echo &quot;QUOTATION MARKS&quot;</div><div class="line"># 版本2以后Bash允许使用$&apos;\nnn&apos;结构.</div><div class="line"># 注意在这里, &apos;\nnn\&apos;是8进制的值.</div><div class="line">echo $&apos;\t \042 \t&apos;   # 被水平制表符括起来的引号(&quot;).</div><div class="line"></div><div class="line"># 当然,也可以使用16进制的值,使用$&apos;\xhhh&apos; 结构.</div><div class="line">echo $&apos;\t \x22 \t&apos;  # 被水平制表符括起来的引号(&quot;).</div><div class="line"># 早一点的Bash版本允许&apos;\x022&apos;这种形式.</div><div class="line">echo &quot;===============&quot;</div><div class="line">echo</div><div class="line"></div><div class="line"></div><div class="line"># 分配ASCII字符到变量中.</div><div class="line"># ----------------------------------------</div><div class="line">quote=$&apos;\042&apos;        # &quot; 被赋值到变量中.</div><div class="line">echo &quot;$quote This is a quoted string, $quote and this lies outside the quotes.&quot;</div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line"># 变量中的连续的ASCII字符.</div><div class="line">triple_underline=$&apos;\137\137\137&apos;  # 137是八进制的&apos;_&apos;.</div><div class="line">echo &quot;$triple_underline UNDERLINE $triple_underline&quot;</div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line">ABC=$&apos;\101\102\103\010&apos;           # 101, 102, 103是八进制码的A, B, C.</div><div class="line">echo $ABC</div><div class="line"></div><div class="line">echo; echo</div><div class="line"></div><div class="line">escape=$&apos;\033&apos;                    # 033 是八进制码的esc.</div><div class="line">echo &quot;\&quot;escape\&quot; echoes as $escape&quot;</div><div class="line">#                                   没有变量被输出.</div><div class="line"></div><div class="line">echo; echo</div><div class="line"></div><div class="line">exit 0</div></pre></td></tr></table></figure>
<p>其中echo的-e参数表示使能反斜线转义</p>
<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div></pre></td></tr></table></figure>
<h3 id="4-转义符（-）的行为探究"><a href="#4-转义符（-）的行为探究" class="headerlink" title="4.转义符（\）的行为探究"></a>4.转义符（\）的行为探究</h3><p>\ 的行为依赖于它自身是否被转义，被引用（””），或者是否出现在命令替换或here document(块变量)中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">                   #  简单的转义和引用</div><div class="line">echo \z               #  z</div><div class="line">echo \\z              # \z</div><div class="line">echo &apos;\z&apos;             # \z</div><div class="line">echo &apos;\\z&apos;            # \\z</div><div class="line">echo &quot;\z&quot;             # \z</div><div class="line">echo &quot;\\z&quot;            # \z</div><div class="line"></div><div class="line">                   #  命令替换</div><div class="line">echo `echo \z`        #  z</div><div class="line">echo `echo \\z`       #  z</div><div class="line">echo `echo \\\z`      # \z</div><div class="line">echo `echo \\\\z`     # \z</div><div class="line">echo `echo \\\\\\z`   # \z</div><div class="line">echo `echo \\\\\\\z`  # \\z</div><div class="line">echo `echo &quot;\z&quot;`      # \z</div><div class="line">echo `echo &quot;\\z&quot;`     # \z</div><div class="line"></div><div class="line">                   # Here document</div><div class="line">cat &lt;&lt;EOF              </div><div class="line">\z                      </div><div class="line">EOF                   # \z</div><div class="line"></div><div class="line">cat &lt;&lt;EOF              </div><div class="line">\\z                     </div><div class="line">EOF                   # \z</div></pre></td></tr></table></figure>
<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div></pre></td></tr></table></figure>
<h3 id="5-变量中的转义"><a href="#5-变量中的转义" class="headerlink" title="5.变量中的转义"></a>5.变量中的转义</h3><p>赋值给变量的字符串的元素也会被转义，但是不能把一个单独的转义符赋值给变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">variable=\</div><div class="line">echo &quot;$variable&quot;</div><div class="line"># 不能正常运行 - 会报错:</div><div class="line"># test.sh: : command not found</div><div class="line"># 一个&quot;裸体的&quot;转义符是不能够安全的赋值给变量的.</div><div class="line">#</div><div class="line">#  事实上在这里&quot;\&quot;转义了一个换行符(变成了续航符的含义), </div><div class="line">#+ 效果就是                variable=echo &quot;$variable&quot;</div><div class="line">#+                      不可用的变量赋值</div><div class="line"></div><div class="line">variable=\</div><div class="line">23skidoo</div><div class="line">echo &quot;$variable&quot;        #  23skidoo</div><div class="line">                        #  这句是可以的, 因为</div><div class="line">                        #+ 第2行是一个可用的变量赋值.</div><div class="line"></div><div class="line">variable=\ </div><div class="line">#             \^    转义一个空格</div><div class="line">echo &quot;$variable&quot;        # 显示空格</div><div class="line"></div><div class="line">variable=\\</div><div class="line">echo &quot;$variable&quot;        # \</div><div class="line"></div><div class="line">variable=\\\</div><div class="line">echo &quot;$variable&quot;</div><div class="line"># 不能正常运行 - 报错:</div><div class="line"># test.sh: \: command not found</div><div class="line">#</div><div class="line">#  第一个转义符把第2个\转义了,但是第3个又变成&quot;裸体的&quot;了,</div><div class="line">#+ 与上边的例子的原因相同.</div><div class="line"></div><div class="line">variable=\\\\</div><div class="line">echo &quot;$variable&quot;        # \\</div><div class="line">                        # 第2和第4个反斜线被转义了.</div><div class="line">                        # 这是正确的.</div></pre></td></tr></table></figure>
<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div></pre></td></tr></table></figure>
<h3 id="6-转义空格"><a href="#6-转义空格" class="headerlink" title="6.转义空格"></a>6.转义空格</h3><p>转义一个空格会阻止命令行参数列表的“单词分割”问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">file_list=&quot;/bin/cat /bin/gzip /bin/more /usr/bin/less /usr/bin/emacs-20.7&quot;</div><div class="line"># 列出的文件都作为命令的参数.</div><div class="line"></div><div class="line"># 加两个文件到参数列表中, 列出所有的文件信息.</div><div class="line">ls -l /usr/lib/gconv /usr $file_list</div><div class="line"></div><div class="line">echo &quot;-------------------------------------------------------------------------&quot;</div><div class="line"></div><div class="line"># 如果我们将上边的两个space转义了会产生什么效果?</div><div class="line">ls -l /usr/lib/gconv\ /usr\ $file_list</div><div class="line"># 错误: 因为前3个路径被合并成一个参数传递给了&apos;ls -l&apos;</div><div class="line">#       而且两个经过转义的空格组织了参数(单词)分割.</div></pre></td></tr></table></figure>
<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div></pre></td></tr></table></figure>
<h3 id="7-续行功能"><a href="#7-续行功能" class="headerlink" title="7.续行功能"></a>7.续行功能</h3><p>转义符也提供续行功能，也就是编写多行命令的功能。</p>
<p>每一个单独行都包含一个不同的命令，但是每行结尾的转义符都会转义换行符，这样下一行会与上一行一起形成一个命令序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">mkdir ~/source</div><div class="line">mkdir ~/dest</div><div class="line">touch ~/source/s.tar</div><div class="line"></div><div class="line">(cd ~/source &amp;&amp; tar cf - . ) | \</div><div class="line">(cd ~/dest &amp;&amp; tar xpvf -)</div><div class="line"># 重复Alan Cox的目录数拷贝命令,</div><div class="line"># 但是分成两行是为了增加可读性.</div><div class="line"></div><div class="line"># 也可以使用如下方式:</div><div class="line"># tar cf - -C ~/source/ . |</div><div class="line"># tar xpvf - -C ~/dest/</div></pre></td></tr></table></figure>
<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div></pre></td></tr></table></figure>
<p>如果一个脚本以 | （管道符）结束，那么就不用加转义符（\）了。但是一个好的编程风格，还是应该在行尾加上转义符。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引用变量&quot;&gt;&lt;a href=&quot;#引用变量&quot; class=&quot;headerlink&quot; title=&quot;引用变量&quot;&gt;&lt;/a&gt;引用变量&lt;/h2&gt;&lt;h3 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1.介绍&quot;&gt;&lt;/a
    
    </summary>
    
      <category term="Shell" scheme="http://yoursite.com/categories/Shell/"/>
    
    
      <category term="Bash" scheme="http://yoursite.com/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>ch4-变量和参数</title>
    <link href="http://yoursite.com/2017/02/07/ch4-%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E5%92%8C%E6%9B%BF%E6%8D%A2/"/>
    <id>http://yoursite.com/2017/02/07/ch4-变量赋值和替换/</id>
    <published>2017-02-07T07:03:43.000Z</published>
    <updated>2017-02-10T09:11:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量替换"><a href="#变量替换" class="headerlink" title="变量替换"></a>变量替换</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>变量的名字就是变量保存值的地方。引用变量的值就叫做变量替换。</p>
<p>如果 variable 是一个变量的名字，那么 $variable 就是引用这变量的值，即这变量所包含的数据。</p>
<p>$variable 事实上只是 ${variable} 的简写形式。在某些上下文中 $variable 可能会引起错误，这时候你就需要用 ${variable} 了。</p>
<h3 id="2-举例"><a href="#2-举例" class="headerlink" title="2.举例"></a>2.举例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入代码（中文皆为注释，不用输入）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line"># 变量赋值和替换</div><div class="line"></div><div class="line">a=375</div><div class="line">hello=$a</div><div class="line"></div><div class="line">#-------------------------------------------------------------------------</div><div class="line"># 强烈注意, 在赋值的的时候, 等号前后一定不要有空格.</div><div class="line"># 如果出现空格会怎么样?</div><div class="line"></div><div class="line">#  &quot;VARIABLE =value&quot;</div><div class="line">#                   ^</div><div class="line">#% 脚本将尝试运行一个&quot;VARIABLE&quot;的命令, 带着一个&quot;=value&quot;参数.</div><div class="line"></div><div class="line">#  &quot;VARIABLE= value&quot;</div><div class="line">#                      ^</div><div class="line">#% 脚本将尝试运行一个&quot;value&quot;的命令, </div><div class="line">#+ 并且带着一个被赋值成&quot;&quot;的环境变量&quot;VARIABLE&quot;. </div><div class="line">#-------------------------------------------------------------------------</div><div class="line"></div><div class="line">echo hello    # 没有变量引用, 只是个hello字符串.</div><div class="line"></div><div class="line">echo $hello</div><div class="line">echo $&#123;hello&#125;</div><div class="line"></div><div class="line">echo &quot;$hello&quot;</div><div class="line">echo &quot;$&#123;hello&#125;&quot;</div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line">hello=&quot;A B  C     D&quot;</div><div class="line">echo $hello   # A B C D</div><div class="line">echo &quot;$hello&quot; # A B  C     D</div><div class="line"># 引用一个变量将保留其中的空白, 当然如果是变量替换就不会保留了.</div><div class="line"># 在bash中，当变量中有空格、tab之类的字符时候，</div><div class="line"># 如果需要打印这些字符，需要用双引号进行引用 &quot;$hello&quot;.</div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line">echo &apos;$hello&apos;  # $hello</div><div class="line">#     ^           ^</div><div class="line"># 全引用（单引号）的作用将会导致&quot;$&quot;被解释为单独的字符, 而不是变量前缀. </div><div class="line"># 使用单引号引用变量时候，变量的值不会被引用，只是简单的保持原始字符串.</div><div class="line"></div><div class="line"># 注意这两种引用所产生的不同的效果.</div><div class="line"></div><div class="line">hello=    # 设置为空值.</div><div class="line">echo &quot;\$hello (null value) = $hello&quot;</div><div class="line">#  注意设置一个变量为null, 与unset这个变量, 并不是一回事</div><div class="line">#+ 虽然最终的结果相同(具体见下边).</div><div class="line"></div><div class="line"># --------------------------------------------------------------</div><div class="line"></div><div class="line">#  可以在同一行上设置多个变量, </div><div class="line">#+ 但是必须以空白进行分隔.</div><div class="line">#  慎用, 这么做会降低可读性, 并且不可移植.</div><div class="line"></div><div class="line">var1=21  var2=22  var3=$V3</div><div class="line">echo</div><div class="line">echo &quot;var1=$var1   var2=$var2   var3=$var3&quot;</div><div class="line"></div><div class="line"># 在老版本的&quot;sh&quot;上可能会引起问题.</div><div class="line"></div><div class="line"># --------------------------------------------------------------</div><div class="line"></div><div class="line">echo; echo</div><div class="line"></div><div class="line">numbers=&quot;one two three&quot;</div><div class="line">#                      ^    ^</div><div class="line">other_numbers=&quot;1 2 3&quot;</div><div class="line">#                           ^ ^</div><div class="line">#  如果在变量中存在空白，那么就必须加上引号</div><div class="line">#  other_numbers=1 2 3                  # 将给出一个错误消息. </div><div class="line">echo &quot;numbers = $numbers&quot;</div><div class="line">echo &quot;other_numbers = $other_numbers&quot;   # other_numbers = 1 2 3</div><div class="line">#  不过也可以采用将空白转义的方法.</div><div class="line">mixed_bag=2\ ---\ Whatever</div><div class="line">#                     ^    ^ 在转义符后边的空格(\).</div><div class="line"></div><div class="line">echo &quot;$mixed_bag&quot;         # 2 --- Whatever</div><div class="line"></div><div class="line">echo; echo</div><div class="line"></div><div class="line">echo &quot;uninitialized_variable = $uninitialized_variable&quot;</div><div class="line"># Uninitialized变量为null(就是没有值). </div><div class="line">uninitialized_variable=   #  声明, 但是没有初始化这个变量, </div><div class="line">                         #+ 其实和前边设置为空值的作用是一样的. </div><div class="line">echo &quot;uninitialized_variable = $uninitialized_variable&quot;</div><div class="line">                         # 还是一个空值.</div><div class="line"></div><div class="line">uninitialized_variable=23       # 赋值.</div><div class="line">unset uninitialized_variable    # Unset这个变量.</div><div class="line">echo &quot;uninitialized_variable = $uninitialized_variable&quot; # 还是一个空值.</div></pre></td></tr></table></figure>
<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div></pre></td></tr></table></figure>
<h2 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h2><h3 id="1-说明"><a href="#1-说明" class="headerlink" title="1.说明"></a>1.说明</h3><p>赋值操作前后都不能有空白。</p>
<p>因为 = 和 -eq 都可以用做条件测试操作，所以不要与这里的赋值操作相混淆。</p>
<p>注意： = 既可以用做条件测试操作，也可以用于赋值操作，这需要视具体的上下文而定。bash中==也可作为条件判断。</p>
<p>2.举例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入代码（中文皆为注释，不用输入）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">a=23              # 简单的赋值</div><div class="line">echo $a</div><div class="line">b=$a</div><div class="line">echo $b</div><div class="line"></div><div class="line"># 现在让我们来点小变化(命令替换).</div><div class="line"></div><div class="line">a=`echo Hello\!`   # 把&apos;echo&apos;命令的结果传给变量&apos;a&apos;</div><div class="line">echo $a</div><div class="line">#  注意, 如果在一个#+的命令替换结构中包含一个(!)的话, </div><div class="line">#+ 那么在命令行下将无法工作.</div><div class="line">#+ 因为这触发了Bash的&quot;历史机制.&quot;</div><div class="line">#  但是, 在脚本中使用的话, 历史功能是被禁用的, 所以就能够正常的运行.</div><div class="line"></div><div class="line">a=`ls -l`         # 把&apos;ls -l&apos;的结果赋值给&apos;a&apos;</div><div class="line">echo $a           # 然而, 如果没有引号的话将会删除ls结果中多余的tab和换行符.</div><div class="line">echo</div><div class="line">echo &quot;$a&quot;         # 如果加上引号的话, 那么就会保留ls结果中的空白符.</div><div class="line">                 # (具体请参阅&quot;引用&quot;的相关章节.)</div><div class="line"></div><div class="line">exit 0</div></pre></td></tr></table></figure>
<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div></pre></td></tr></table></figure>
<h2 id="变量不区分类型"><a href="#变量不区分类型" class="headerlink" title="变量不区分类型"></a>变量不区分类型</h2><h3 id="1-说明-1"><a href="#1-说明-1" class="headerlink" title="1.说明"></a>1.说明</h3><p>与大多数编译型语言不同，Bash并不区分变量的”类型”。本质上，Bash变量都是字符串。但是依赖于具体的上下文，Bash也允许比较操作和整数操作。其中的关键因素就是，为变量赋的值是否只有数字。</p>
<h3 id="2-举例-1"><a href="#2-举例-1" class="headerlink" title="2.举例"></a>2.举例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入代码（中文皆为注释，不用输入）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">a=2334                   # 整型.</div><div class="line">let &quot;a += 1&quot;</div><div class="line">echo &quot;a = $a&quot;           # a = 2335</div><div class="line">echo                     # 还是整型.</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">b=$&#123;a/23/BB&#125;             # 将&quot;23&quot;替换成&quot;BB&quot;.</div><div class="line">                        # 这将把变量b从整型变为字符串.</div><div class="line">echo &quot;b = $b&quot;            # b = BB35</div><div class="line">declare -i b             # 即使使用declare命令也不会对此有任何帮助，低版本bash下可能没有此命令</div><div class="line">echo &quot;b = $b&quot;            # b = BB35</div><div class="line"># declare的命令是用于设置变量的属性，个别版本的bash可能没有此命令</div><div class="line"></div><div class="line">let &quot;b += 1&quot;             # BB35 + 1 =</div><div class="line">echo &quot;b = $b&quot;            # b = 1</div><div class="line">echo</div><div class="line"></div><div class="line">c=BB34</div><div class="line">echo &quot;c = $c&quot;            # c = BB34</div><div class="line">d=$&#123;c/BB/23&#125;             # 将&quot;BB&quot;替换成&quot;23&quot;.</div><div class="line">                        # 这使得变量$d变为一个整形.</div><div class="line">echo &quot;d = $d&quot;            # d = 2334</div><div class="line">let &quot;d += 1&quot;             # 2334 + 1 =</div><div class="line">echo &quot;d = $d&quot;            # d = 2335</div><div class="line">echo</div><div class="line"></div><div class="line"># null变量会如何呢?</div><div class="line">e=&quot;&quot;</div><div class="line">echo &quot;e = $e&quot;            # e =</div><div class="line">let &quot;e += 1&quot;             # 算术操作允许一个null变量?</div><div class="line">echo &quot;e = $e&quot;            # e = 1</div><div class="line">echo                     # null变量将被转换成一个整型变量.</div><div class="line"></div><div class="line"># 如果没有声明变量会怎样?</div><div class="line">echo &quot;f = $f&quot;            # f =</div><div class="line">let &quot;f += 1&quot;             # 算术操作能通过么?</div><div class="line">echo &quot;f = $f&quot;            # f = 1</div><div class="line">echo                     # 未声明的变量将转换成一个整型变量.</div><div class="line"></div><div class="line"># 所以说Bash中的变量都是不区分类型的.</div><div class="line">exit 0</div></pre></td></tr></table></figure>
<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div></pre></td></tr></table></figure>
<h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><h3 id="1-局部变量"><a href="#1-局部变量" class="headerlink" title="1.局部变量"></a>1.局部变量</h3><p>这种变量只有在代码块或者函数中才可见。后面的实验会详细讲解。</p>
<h3 id="2-环境变量"><a href="#2-环境变量" class="headerlink" title="2.环境变量"></a>2.环境变量</h3><p>这种变量将影响用户接口和 shell 的行为。</p>
<p>在通常情况下，每个进程都有自己的“环境”，这个环境是由一组变量组成的，这些变量中存有进程可能需要引用的信息。在这种情况下，shell 与一个一般的进程没什么区别。</p>
<h3 id="3-位置参数"><a href="#3-位置参数" class="headerlink" title="3.位置参数"></a>3.位置参数</h3><p>从命令行传递到脚本的参数：$0，$1，$2，$3…</p>
<p>$0就是脚本文件自身的名字，$1 是第一个参数，$2 是第二个参数，$3 是第三个参数，然后是第四个。$9 之后的位置参数就必须用大括号括起来了，比如，${10}，${11}，${12}。</p>
<p>两个比较特殊的变量 $* 和 $@ 表示所有的位置参数。</p>
<h3 id="4-位置参数实例"><a href="#4-位置参数实例" class="headerlink" title="4.位置参数实例"></a>4.位置参数实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入代码（中文皆为注释，不用输入）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line"># 作为用例, 调用这个脚本至少需要10个参数, 比如:</div><div class="line"># bash test.sh 1 2 3 4 5 6 7 8 9 10</div><div class="line">MINPARAMS=10</div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line">echo &quot;The name of this script is \&quot;$0\&quot;.&quot;</div><div class="line"># 添加./是表示当前目录</div><div class="line">echo &quot;The name of this script is \&quot;`basename $0`\&quot;.&quot;</div><div class="line"># 去掉路径名, 剩下文件名, (参见&apos;basename&apos;)</div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line">if [ -n &quot;$1&quot; ]              # 测试变量被引用.</div><div class="line">then</div><div class="line">echo &quot;Parameter #1 is $1&quot;  # 需要引用才能够转义&quot;#&quot;</div><div class="line">fi </div><div class="line"></div><div class="line">if [ -n &quot;$2&quot; ]</div><div class="line">then</div><div class="line">echo &quot;Parameter #2 is $2&quot;</div><div class="line">fi </div><div class="line"></div><div class="line">if [ -n &quot;$3&quot; ]</div><div class="line">then</div><div class="line">echo &quot;Parameter #3 is $3&quot;</div><div class="line">fi</div><div class="line"></div><div class="line">if [ -n &quot;$4&quot; ]</div><div class="line">then</div><div class="line">echo &quot;Parameter #4 is $4&quot;</div><div class="line">fi</div><div class="line"></div><div class="line">if [ -n &quot;$5&quot; ]</div><div class="line">then</div><div class="line">echo &quot;Parameter #5 is $5&quot;</div><div class="line">fi</div><div class="line"></div><div class="line">if [ -n &quot;$6&quot; ]</div><div class="line">then</div><div class="line">echo &quot;Parameter #6 is $6&quot;</div><div class="line">fi</div><div class="line"></div><div class="line">if [ -n &quot;$7&quot; ]</div><div class="line">then</div><div class="line">echo &quot;Parameter #7 is $7&quot;</div><div class="line">fi</div><div class="line"></div><div class="line">if [ -n &quot;$8&quot; ]</div><div class="line">then</div><div class="line">echo &quot;Parameter #8 is $8&quot;</div><div class="line">fi</div><div class="line"></div><div class="line">if [ -n &quot;$9&quot; ]</div><div class="line">then</div><div class="line">echo &quot;Parameter #9 is $9&quot;</div><div class="line">fi</div><div class="line"></div><div class="line">if [ -n &quot;$&#123;10&#125;&quot; ]  # 大于$9的参数必须用&#123;&#125;括起来.</div><div class="line">then</div><div class="line">echo &quot;Parameter #10 is $&#123;10&#125;&quot;</div><div class="line">fi </div><div class="line"></div><div class="line">echo &quot;-----------------------------------&quot;</div><div class="line">echo &quot;All the command-line parameters are: &quot;$*&quot;&quot;</div><div class="line"></div><div class="line">if [ $# -lt &quot;$MINPARAMS&quot; ]</div><div class="line">then</div><div class="line"> echo</div><div class="line"> echo &quot;This script needs at least $MINPARAMS command-line arguments!&quot;</div><div class="line">fi  </div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line">exit 0</div></pre></td></tr></table></figure>
<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh 1 2 3 4 5 6 7 8 9 10</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;变量替换&quot;&gt;&lt;a href=&quot;#变量替换&quot; class=&quot;headerlink&quot; title=&quot;变量替换&quot;&gt;&lt;/a&gt;变量替换&lt;/h2&gt;&lt;h3 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1.概念&quot;&gt;&lt;/a
    
    </summary>
    
      <category term="Shell" scheme="http://yoursite.com/categories/Shell/"/>
    
    
      <category term="Bash" scheme="http://yoursite.com/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>ch2-Bash中的特殊字符（上）</title>
    <link href="http://yoursite.com/2017/02/06/ch2-Bash%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/06/ch2-Bash中的特殊字符（上）/</id>
    <published>2017-02-06T02:49:04.000Z</published>
    <updated>2017-02-10T09:10:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><h3 id="1-注释"><a href="#1-注释" class="headerlink" title="1.# 注释"></a>1.# 注释</h3><p>行首以 # 开头(除#!之外)的是注释。#!是用于指定当前脚本的解释器，我们这里为bash，且应该指明完整路径，所以为/bin/bash</p>
<p>当然，在echo中转义的 # 是不能作为注释的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入如下代码，并保存。（中文为注释，无需要输入）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">echo &quot;The # here does not begin a comment.&quot;</div><div class="line">echo &apos;The # here does not begin a comment.&apos;</div><div class="line">echo The \# here does not begin a comment.</div><div class="line">echo The # 这里开始一个注释</div><div class="line"></div><div class="line">echo $&#123;PATH#*:&#125;         # 字符串截取，不是一个注释</div><div class="line">echo $(( 2#101011 ))   # 数制转换（使用二进制表示），不是一个注释</div></pre></td></tr></table></figure>
<p>执行脚本，查看输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div></pre></td></tr></table></figure>
<p>解释说明</p>
<p>上面的脚本说明了如何使用echo打印出一段字符串和变量内容，这里采用了几种不同的方式</p>
<h2 id="分号（-）"><a href="#分号（-）" class="headerlink" title="分号（;）"></a>分号（;）</h2><h3 id="1-命令分隔符"><a href="#1-命令分隔符" class="headerlink" title="1.命令分隔符"></a>1.命令分隔符</h3><p>使用分号（;）可以在同一行上写两个或两个以上的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test2.sh</div></pre></td></tr></table></figure>
<p>输入如下代码，并保存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">echo hello; echo there</div><div class="line">filename=ttt.sh</div><div class="line">if [ -r &quot;$filename&quot; ]; then    # 注意: &quot;if&quot;和&quot;then&quot;需要分隔</div><div class="line">    echo &quot;File $filename exists.&quot;; cp $filename $filename.bak</div><div class="line">else</div><div class="line">    echo &quot;File $filename not found.&quot;; touch $filename</div><div class="line">fi; echo &quot;File test complete.&quot;</div></pre></td></tr></table></figure>
<p>执行脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bash test2.sh</div></pre></td></tr></table></figure>
<p>查看结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ls</div></pre></td></tr></table></figure>
<p>解释说明</p>
<p>上面脚本使用了一个if件分支判断一个文件是否存在，如果文件存在打印相关信息并将该文件备份；如果不存在打印相关信息并创建一个新的文件。</p>
<h3 id="2-终止case选项（双分号）"><a href="#2-终止case选项（双分号）" class="headerlink" title="2.终止case选项（双分号）"></a>2.终止case选项（双分号）</h3><p>使用双分号（;;）可以终止case选项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test3.sh</div></pre></td></tr></table></figure>
<p>输入如下代码，并保存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">varname=b</div><div class="line"></div><div class="line">case &quot;$varname&quot; in</div><div class="line">    [a-z]) echo &quot;abc&quot;;;</div><div class="line">    [0-9]) echo &quot;123&quot;;;</div><div class="line">esac</div></pre></td></tr></table></figure>
<p>执行脚本，查看输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ bash test3.sh</div><div class="line">abc</div></pre></td></tr></table></figure>
<p>解释说明</p>
<p>上面脚本使用case语句，首先创建了一个变量初始化为b,然后使用case语句判断该变量的范围，并打印相关信息。</p>
<h2 id="点号（-）"><a href="#点号（-）" class="headerlink" title="点号（.）"></a>点号（.）</h2><h2 id="1-等价于-source-命令"><a href="#1-等价于-source-命令" class="headerlink" title="1.等价于 source 命令"></a>1.等价于 source 命令</h2><p>bash 中的 source 命令用于在当前 bash 环境下读取并执行 FileName.sh 中的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ source test.sh</div><div class="line">Hello World</div><div class="line">$ . test.sh</div><div class="line">Hello World</div></pre></td></tr></table></figure>
<h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><h3 id="1-双引号（”"><a href="#1-双引号（”" class="headerlink" title="1.双引号（”)"></a>1.双引号（”)</h3><p>“STRING” 将会阻止（解释）STRING中大部分特殊的字符。后面的实验会详细说明。</p>
<h3 id="2-单引号（’）"><a href="#2-单引号（’）" class="headerlink" title="2.单引号（’）"></a>2.单引号（’）</h3><p>‘STRING’ 将会阻止STRING中所有特殊字符的解释，这是一种比使用”更强烈的形式。后面的实验会详细说明。</p>
<h2 id="斜线和反斜线"><a href="#斜线和反斜线" class="headerlink" title="斜线和反斜线"></a>斜线和反斜线</h2><h3 id="1-斜线（-）"><a href="#1-斜线（-）" class="headerlink" title="1.斜线（/）"></a>1.斜线（/）</h3><p>文件名路径分隔符。分隔文件名不同的部分（如/home/bozo/projects/Makefile）。也可以用来作为除法算术操作符。</p>
<h3 id="2-反斜线（-）"><a href="#2-反斜线（-）" class="headerlink" title="2.反斜线（\）"></a>2.反斜线（\）</h3><p>一种对单字符的引用机制。\X 将会“转义”字符X。这等价于”X”，也等价于’X’。\ 通常用来转义双引号（”）和单引号（’），这样双引号和单引号就不会被解释成特殊含义了。</p>
<h2 id="反引号（-）"><a href="#反引号（-）" class="headerlink" title="反引号（`）"></a>反引号（`）</h2><h3 id="1-命令替换"><a href="#1-命令替换" class="headerlink" title="1.命令替换"></a>1.命令替换</h3><p>command 结构可以将命令的输出赋值到一个变量中去。在后边的后置引用(backquotes)或后置标记(backticks)中也会讲解。</p>
<p>反引号中的命令会优先执行，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cp `mkdir back` test.sh back</div><div class="line">$ ls</div></pre></td></tr></table></figure>
<p>先创建了 back 目录，然后复制 test.sh 到 back 目录</p>
<h2 id="冒号（-）"><a href="#冒号（-）" class="headerlink" title="冒号（:）"></a>冒号（:）</h2><h3 id="1-空命令"><a href="#1-空命令" class="headerlink" title="1.空命令"></a>1.空命令</h3><p>等价于“NOP”（no op，一个什么也不干的命令）。也可以被认为与shell的内建命令true作用相同。“:”命令是一个bash的内建命令，它的退出码（exit status）是（0）。</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">while :</div><div class="line">do</div><div class="line">    echo &quot;endless loop&quot;</div><div class="line">done</div></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">while true</div><div class="line">do</div><div class="line">    echo &quot;endless loop&quot;</div><div class="line">done</div></pre></td></tr></table></figure>
<p>可以在 if/then 中作占位符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">condition=5</div><div class="line"></div><div class="line">if [ $condition -gt 0 ]</div><div class="line">then :   # 什么都不做，退出分支</div><div class="line">else</div><div class="line">    echo &quot;$condition&quot;</div><div class="line">fi</div></pre></td></tr></table></figure>
<h3 id="2-变量扩展-子串替换"><a href="#2-变量扩展-子串替换" class="headerlink" title="2.变量扩展/子串替换"></a>2.变量扩展/子串替换</h3><p>在与&gt;重定向操作符结合使用时，将会把一个文件清空，但是并不会修改这个文件的权限。如果之前这个文件并不存在，那么就创建这个文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ : &gt; test.sh   # 文件“test.sh”现在被清空了</div><div class="line"># 与 cat /dev/null &gt; test.sh 的作用相同</div><div class="line"># 然而,这并不会产生一个新的进程, 因为“:”是一个内建命令</div></pre></td></tr></table></figure>
<p>在与&gt;&gt;重定向操作符结合使用时，将不会对预先存在的目标文件(: &gt;&gt; target_file)产生任何影响。如果这个文件之前并不存在，那么就创建它。</p>
<p>也可能用来作为注释行，但不推荐这么做。使用 # 来注释的话，将关闭剩余行的错误检查，所以可以在注释行中写任何东西。然而，使用 : 的话将不会这样。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ : This is a comment that generates an error, ( if [ $x -eq 3] )</div></pre></td></tr></table></figure>
<p>“:”还用来在 /etc/passwd 和 PATH 变量中做分隔符，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ echo $PATH</div><div class="line">/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/sbin:/usr/sbin:/usr/games</div><div class="line">$</div></pre></td></tr></table></figure>
<h2 id="问号（-）"><a href="#问号（-）" class="headerlink" title="问号（?）"></a>问号（?）</h2><h3 id="1-测试操作符"><a href="#1-测试操作符" class="headerlink" title="1.测试操作符"></a>1.测试操作符</h3><p>在一个双括号结构中，? 就是C语言的三元操作符，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入如下代码，并保存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">a=10</div><div class="line">(( t=a&lt;50?8:9 ))</div><div class="line">echo $t</div></pre></td></tr></table></figure>
<p>运行测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div><div class="line">8</div></pre></td></tr></table></figure>
<h2 id="美元符号"><a href="#美元符号" class="headerlink" title="美元符号"></a>美元符号</h2><h3 id="1-变量替换"><a href="#1-变量替换" class="headerlink" title="1.变量替换"></a>1.变量替换</h3><p>前面已经用到了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">var1=5</div><div class="line">var2=23skidoo</div><div class="line"></div><div class="line">echo $var1     # 5</div><div class="line">echo $var2     # 23skidoo</div></pre></td></tr></table></figure>
<p>运行测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div></pre></td></tr></table></figure>
<h3 id="2-命令替换（同反引号）"><a href="#2-命令替换（同反引号）" class="headerlink" title="2.命令替换（同反引号）"></a>2.命令替换（同反引号）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd $(echo Documents)</div><div class="line">$ pwd</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;符号&quot;&gt;&lt;a href=&quot;#符号&quot; class=&quot;headerlink&quot; title=&quot;符号&quot;&gt;&lt;/a&gt;符号&lt;/h2&gt;&lt;h3 id=&quot;1-注释&quot;&gt;&lt;a href=&quot;#1-注释&quot; class=&quot;headerlink&quot; title=&quot;1.# 注释&quot;&gt;&lt;/a&gt;1.# 注
    
    </summary>
    
      <category term="Shell" scheme="http://yoursite.com/categories/Shell/"/>
    
    
      <category term="Bash" scheme="http://yoursite.com/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>ch3-Bash中的特殊字符（下）</title>
    <link href="http://yoursite.com/2017/02/06/ch3-Bash%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/06/ch3-Bash中的特殊字符（下）/</id>
    <published>2017-02-06T02:49:04.000Z</published>
    <updated>2017-02-10T09:11:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="小括号（-）"><a href="#小括号（-）" class="headerlink" title="小括号（( )）"></a>小括号（( )）</h2><h3 id="1-命令组"><a href="#1-命令组" class="headerlink" title="1.命令组"></a>1.命令组</h3><p>在括号中的命令列表，将会作为一个子 shell 来运行。</p>
<p>在括号中的变量，由于是在子shell中，所以对于脚本剩下的部分是不可用的。父进程，也就是脚本本身，将不能够读取在子进程中创建的变量，也就是在子shell 中创建的变量。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">a=123</div><div class="line">( a=321; )</div><div class="line"></div><div class="line">echo &quot;a = $a&quot;</div></pre></td></tr></table></figure>
<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div><div class="line">a = 123</div></pre></td></tr></table></figure>
<p>在圆括号中 a 变量，更像是一个局部变量。</p>
<h3 id="2-初始化数组"><a href="#2-初始化数组" class="headerlink" title="2.初始化数组"></a>2.初始化数组</h3><p>创建数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">arr=(1 4 5 7 9 21)</div><div class="line">echo $&#123;arr[3]&#125; # get a value of arr</div></pre></td></tr></table></figure>
<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div><div class="line">7</div></pre></td></tr></table></figure>
<h2 id="大括号（-）"><a href="#大括号（-）" class="headerlink" title="大括号（{ }）"></a>大括号（{ }）</h2><h3 id="1-文件名扩展"><a href="#1-文件名扩展" class="headerlink" title="1.文件名扩展"></a>1.文件名扩展</h3><p>复制 t.txt 的内容到 t.back 中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">if [ ! -w &apos;t.txt&apos; ];</div><div class="line">then</div><div class="line">    touch t.txt</div><div class="line">fi</div><div class="line">echo &apos;test text&apos; &gt;&gt; t.txt</div><div class="line">cp t.&#123;txt,back&#125;</div></pre></td></tr></table></figure>
<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div></pre></td></tr></table></figure>
<p>查看运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ls</div><div class="line">$ cat t.txt</div><div class="line">$ cat t.back</div></pre></td></tr></table></figure>
<p>注意： 在大括号中，不允许有空白，除非这个空白被引用或转义。</p>
<h3 id="2-代码块"><a href="#2-代码块" class="headerlink" title="2.代码块"></a>2.代码块</h3><p>代码块，又被称为内部组，这个结构事实上创建了一个匿名函数（一个没有名字的函数）。然而，与“标准”函数不同的是，在其中声明的变量，对于脚本其他部分的代码来说还是可见的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">a=123</div><div class="line">&#123; a=321; &#125;</div><div class="line">echo &quot;a = $a&quot;</div></pre></td></tr></table></figure>
<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div><div class="line">a = 321</div></pre></td></tr></table></figure>
<p>变量 a 的值被更改了。</p>
<h2 id="中括号（-）"><a href="#中括号（-）" class="headerlink" title="中括号（[ ]）"></a>中括号（[ ]）</h2><h3 id="1-条件测试"><a href="#1-条件测试" class="headerlink" title="1.条件测试"></a>1.条件测试</h3><p>条件测试表达式放在[ ]中。值得注意的是[是shell内建test命令的一部分，并不是/usr/bin/test中的外部命令的一个链接。下列练习中的-lt (less than)表示小于号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure></p>
<p>输入代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">a=5</div><div class="line">if [ $a -lt 10 ]</div><div class="line">then</div><div class="line">    echo &quot;a: $a&quot;</div><div class="line">else</div><div class="line">    echo &apos;a&gt;10&apos;</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div><div class="line">a: 5</div><div class="line">$</div></pre></td></tr></table></figure>
<h3 id="2-数组元素"><a href="#2-数组元素" class="headerlink" title="2.数组元素"></a>2.数组元素</h3><p>在一个array结构的上下文中，中括号用来引用数组中每个元素的索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">arr=(12 22 32)</div><div class="line">arr[0]=10</div><div class="line">echo $&#123;arr[0]&#125;</div></pre></td></tr></table></figure>
<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div><div class="line">10</div></pre></td></tr></table></figure>
<h2 id="尖括号（-lt-和-gt-）"><a href="#尖括号（-lt-和-gt-）" class="headerlink" title="尖括号（&lt; 和 &gt;）"></a>尖括号（&lt; 和 &gt;）</h2><h3 id="1-重定向"><a href="#1-重定向" class="headerlink" title="1.重定向"></a>1.重定向</h3><p>test.sh &gt; filename 重定向test.sh的输出到文件 filename 中。如果 filename 存在的话，那么将会被覆盖。</p>
<p>test.sh &amp;&gt; filename 重定向 test.sh 的 stdout（标准输出）和 stderr（标准错误）到 filename 中。</p>
<p>test.sh &gt;&amp;2 重定向 test.sh 的 stdout 到 stderr 中。</p>
<p>test.sh &gt;&gt; filename 把 test.sh 的输出追加到文件 filename 中。如果filename 不存在的话，将会被创建。</p>
<h2 id="竖线（-）"><a href="#竖线（-）" class="headerlink" title="竖线（|）"></a>竖线（|）</h2><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>分析前边命令的输出，并将输出作为后边命令的输入。这是一种产生命令链的好方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">tr &apos;a-z&apos; &apos;A-Z&apos;</div><div class="line">exit 0</div></pre></td></tr></table></figure>
<p>现在让我们输送ls -l的输出到一个脚本中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ chmod 755 test.sh</div><div class="line">$ ls -l | ./test.sh</div></pre></td></tr></table></figure>
<p>输出的内容均变为了大写字母。</p>
<h2 id="破折号（-）"><a href="#破折号（-）" class="headerlink" title="破折号（-）"></a>破折号（-）</h2><h3 id="1-选项，前缀"><a href="#1-选项，前缀" class="headerlink" title="1.选项，前缀"></a>1.选项，前缀</h3><p>在所有的命令内如果想使用选项参数的话,前边都要加上“-”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">a=5</div><div class="line">b=5</div><div class="line">if [ &quot;$a&quot; -eq &quot;$b&quot; ]</div><div class="line">then</div><div class="line">    echo &quot;a is equal to b.&quot;</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div><div class="line">a is equal to b.</div><div class="line">2.用于重定向stdin或stdout</div></pre></td></tr></table></figure>
<p>下面脚本用于备份最后24小时当前目录下所有修改的文件.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test.sh</div></pre></td></tr></table></figure>
<p>输入代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">BACKUPFILE=backup-$(date +%m-%d-%Y)</div><div class="line"># 在备份文件中嵌入时间.</div><div class="line">archive=$&#123;1:-$BACKUPFILE&#125;</div><div class="line">#  如果在命令行中没有指定备份文件的文件名,</div><div class="line">#+ 那么将默认使用&quot;backup-MM-DD-YYYY.tar.gz&quot;.</div><div class="line"></div><div class="line">tar cvf - `find . -mtime -1 -type f -print` &gt; $archive.tar</div><div class="line">gzip $archive.tar</div><div class="line">echo &quot;Directory $PWD backed up in archive file \&quot;$archive.tar.gz\&quot;.&quot;</div><div class="line"></div><div class="line">exit 0</div></pre></td></tr></table></figure>
<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div><div class="line">$ ls</div></pre></td></tr></table></figure>
<h2 id="波浪号（-）"><a href="#波浪号（-）" class="headerlink" title="波浪号（~）"></a>波浪号（~）</h2><h3 id="1-目录"><a href="#1-目录" class="headerlink" title="1.目录"></a>1.目录</h3><p>~ 表示 home 目录。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;小括号（-）&quot;&gt;&lt;a href=&quot;#小括号（-）&quot; class=&quot;headerlink&quot; title=&quot;小括号（( )）&quot;&gt;&lt;/a&gt;小括号（( )）&lt;/h2&gt;&lt;h3 id=&quot;1-命令组&quot;&gt;&lt;a href=&quot;#1-命令组&quot; class=&quot;headerlink&quot; ti
    
    </summary>
    
      <category term="Shell" scheme="http://yoursite.com/categories/Shell/"/>
    
    
      <category term="Bash" scheme="http://yoursite.com/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>ch1-Bash介绍与入门</title>
    <link href="http://yoursite.com/2017/02/06/ch1-Bash%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2017/02/06/ch1-Bash介绍与入门/</id>
    <published>2017-02-06T02:49:04.000Z</published>
    <updated>2017-02-10T09:10:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Bash？"><a href="#什么是Bash？" class="headerlink" title="什么是Bash？"></a>什么是Bash？</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p><strong>Bash（GNU Bourne-Again Shell）</strong>是一个为GNU计划编写的Unix shell，它是许多Linux平台默认使用的shell。<br>shell是一个命令解释器，是介于操作系统内核与用户之间的一个中间层。准确地说，它也是能力很强的计算机语言，被称为解释性语言或脚本语言。它可以通过将系统调用、公共程序、工具和编译过的二进制程序”粘合“在一起来建立应用，这是大多数脚本语言的共同特征</p>
<p>事实上，所有的UNIX命令和工具再加上公共程序，对于shell脚本来说，都是可调用的。Shell脚本对于管理系统任务和其它的重复工作的例程来说，表现的非常好，根本不需要那些华而不实的成熟紧凑的编译型程序语言。</p>
<h3 id="2-为什么学Bash？"><a href="#2-为什么学Bash？" class="headerlink" title="2.为什么学Bash？"></a>2.为什么学Bash？</h3><p>对于任何想适当精通一些系统管理知识的人来说，掌握shell脚本知识都是最基本的，即使这些人可能并不打算真正的编写一些脚本。</p>
<h2 id="初步练习"><a href="#初步练习" class="headerlink" title="初步练习"></a>初步练习</h2><h3 id="1-Hello-World"><a href="#1-Hello-World" class="headerlink" title="1.Hello World"></a>1.Hello World</h3><p>Bash之Hello World  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim hello.sh</div></pre></td></tr></table></figure>
<p>使用vim编辑hello.sh ，输入如下代码并保存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">#this is a comment</div><div class="line">echo Hello World</div></pre></td></tr></table></figure>
<p>运行Bash脚本的方式：</p>
<p>使用shell来执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sh hello.sh</div><div class="line"># 使用bash来执行</div><div class="line">$ bash hello.sh</div></pre></td></tr></table></figure>
<p>还可以让脚本本身就具有<strong>可执行权限</strong>，通过chmod命令可以修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 赋予脚本的所有者该执行权限，允许该用户执行该脚本</div><div class="line">$ chmod u+rx hello.sh</div><div class="line"># 执行命令，这将使用脚本第一行指定的shell来执行，如果指定shell不存在，将使用系统默认shell来执行</div><div class="line">$  ./hello.sh</div></pre></td></tr></table></figure>
<h3 id="2-使用脚本清除-var-log下的log文件"><a href="#2-使用脚本清除-var-log下的log文件" class="headerlink" title="2.使用脚本清除/var/log下的log文件"></a>2.使用脚本清除/var/log下的log文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim cleanlogs.sh</div></pre></td></tr></table></figure>
<p>输入如下代码，并保存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line"># 初始化一个变量</div><div class="line">LOG_DIR=/var/log</div><div class="line"></div><div class="line">cd $LOG_DIR</div><div class="line"></div><div class="line">cat /dev/null &gt; messages</div><div class="line">cat /dev/null &gt; wtmp</div><div class="line"></div><div class="line">echo &quot;Logs cleaned up.&quot;</div><div class="line"></div><div class="line">exit</div></pre></td></tr></table></figure>
<p>运行脚本前，先看看 /var/log/ 下文件内是否有内容。运行此脚本后，文件的内容将被清除。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是Bash？&quot;&gt;&lt;a href=&quot;#什么是Bash？&quot; class=&quot;headerlink&quot; title=&quot;什么是Bash？&quot;&gt;&lt;/a&gt;什么是Bash？&lt;/h2&gt;&lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="Shell" scheme="http://yoursite.com/categories/Shell/"/>
    
    
      <category term="Bash" scheme="http://yoursite.com/tags/Bash/"/>
    
  </entry>
  
</feed>
